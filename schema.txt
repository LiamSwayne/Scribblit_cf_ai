-- SQL schema for Cloudflare D1 users table
-- This table stores serialized user data alongside metadata fields.
-- The user object's data field is kind of like a database of all their stuff, but all the querying is done on the front-end, which is faster and reduces the worker request count

CREATE TABLE IF NOT EXISTS users (
    user_id TEXT UNIQUE,                    -- corresponds to User.userId (NULL for guest/default users)
    email TEXT UNIQUE,                      -- corresponds to User.email (NULL for guest/default users)
    verified_email BOOLEAN NOT NULL,        -- whether the user's email has been verified
    data TEXT NOT NULL,                          -- JSON-stringified user data, anything we don't need to query, and that it's ok for the user to forge, can go in here
    dataspec INTEGER NOT NULL,              -- version of the data specification (e.g., 1)
    usage INTEGER NOT NULL,                 -- usage count (>= 0)
    timestamp INTEGER NOT NULL,             -- timestamp (ms since epoch)
    plan TEXT NOT NULL, -- subscription plan
    payment_times TEXT NOT NULL, -- array of unix times of payment
    login_attempts TEXT NOT NULL, -- array of unix times they attempted login
    google_auth BOOLEAN, -- is this a google account or a regular email login
    provider TEXT NOT NULL, -- OAuth provider (e.g. 'email' or 'google')
    provider_id TEXT, -- OAuth provider user ID (e.g. provider sub/id)
    password_hash TEXT, -- only users using regular email account have this, google auth users don't need it
    stripe_account_id TEXT,
    salt TEXT
);

-- Note: UNIQUE constraints on user_id and email allow multiple NULLs (SQLite semantics).
-- You can add further indexes if needed, but UNIQUE constraints already create indexes on those columns.
-- All data should be put in the data column if possible. If a piece of data being forged is an issue, it cannot be in the data column, since that column can be arbitrarily edited by the front-end