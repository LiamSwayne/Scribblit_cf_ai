{
  "version": 3,
  "sources": ["../../../main.js"],
  "sourceRoot": "/Volumes/Liam's Works/Programming/Scribblit/private_v2/.wrangler/tmp/deploy-pR7MBm",
  "sourcesContent": ["const SERVER_DOMAIN_OLD = 'scribblit-production.unrono.workers.dev';\nconst SERVER_DOMAIN = 'app.scribbl.it';\nconst OLD_PAGES_DOMAIN = 'scribblit2.pages.dev';\nconst PAGES_DOMAIN = 'scribbl.it';\n\nlet MODELS = {\n    GEMINI_MODELS: {\n        flash: 'gemini-2.5-flash',\n        flash_lite: 'gemini-2.5-flash-lite-preview-06-17'\n    },\n    \n    ANTHROPIC_MODELS: {\n        haiku: 'claude-3-5-haiku-20241022',\n        sonnet: 'claude-sonnet-4-20250514'\n    },\n    \n    GROQ_MODELS: {\n        qwen3: 'qwen/qwen3-32b'\n    },\n    \n    CEREBRAS_MODELS: {\n        qwen3: 'qwen-3-32b'\n    }\n}\n\nfunction SEND(data, status = 200, headers = {}) {\n    const corsHeaders = {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET, HEAD, POST, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    };\n\n    if (typeof data === 'object' && data !== null) {\n        data = JSON.stringify(data);\n        if (!headers['Content-Type']) {\n            headers['Content-Type'] = 'application/json';\n        }\n    }\n\n    return new Response(data, {\n        status,\n        headers: {\n            ...corsHeaders,\n            ...headers\n        },\n    });\n}\n\nasync function hash(password, salt = \"\") {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(password + salt);\n    const digest = await crypto.subtle.digest('SHA-256', data);\n    return btoa(String.fromCharCode(...new Uint8Array(digest)));\n}\n\nasync function verifyToken(token, secret_key) {\n    try {\n        const [payloadBase64, signatureBase64] = token.split('.');\n        const payload = JSON.parse(atob(payloadBase64));\n\n        if (payload.exp && Date.now() / 1000 > payload.exp) {\n            return null; // Token expired\n        }\n\n        const signature = Uint8Array.from(atob(signatureBase64), c => c.charCodeAt(0));\n        const encoder = new TextEncoder();\n        const key = await crypto.subtle.importKey(\n            'raw',\n            encoder.encode(secret_key), {\n                name: 'HMAC',\n                hash: 'SHA-256'\n            },\n            false,\n            ['verify']\n        );\n        const data = encoder.encode(JSON.stringify(payload));\n        const isValid = await crypto.subtle.verify('HMAC', key, signature, data);\n        if (!isValid) {\n            return null;\n        }\n        return payload.email;\n    } catch (err) {\n        return null;\n    }\n}\n\nasync function generateToken(email, secret_key) {\n    const payload = {\n        email,\n        exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 30) // 30 days\n    };\n    const payloadBase64 = btoa(JSON.stringify(payload));\n    const encoder = new TextEncoder();\n    const key = await crypto.subtle.importKey(\n        'raw',\n        encoder.encode(secret_key), {\n            name: 'HMAC',\n            hash: 'SHA-256'\n        },\n        false,\n        ['sign']\n    );\n    const data = encoder.encode(JSON.stringify(payload));\n    const signature = await crypto.subtle.sign('HMAC', key, data);\n    const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signature)));\n    return `${payloadBase64}.${signatureBase64}`;\n}\n\nconst systemPrompt = `You are an AI that takes in user input and converts it to tasks, events, and reminders JSON. If something has to be done *by* a certain date/time but can be done before then, it is a task. If something has to be done at a specific date/time and cannot be done before then, it is an event. It is possible for an event to have only a start time if the end time is unknown. A reminder is a special case of something insignificant to be reminded of at a specific time and date. Only include OPTIONAL fields if the user specified the information needed for that field.\n\nTask JSON:\n{\n    \"type\": \"task\"\n    \"name\": // use sentence case  \n    \"instances\": [ // 2 options\n\t    {\n\t\t    \"type\": \"due_date_instance\"\n\t\t    \"date\": \"YYYY-MM-DD\" // OPTIONAL. if a time a is given then assume the due date is today\n\t\t    \"time\": \"HH:MM\"// OPTIONAL. if it's due today and the current time is past noon assume numbers below 12 are pm.\n\t    }\n\t    {\n\t\t    \"type\": \"due_date_pattern\"\n\t\t    \"pattern\": // 4 options\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"every_n_days_pattern\"\n\t\t\t\t\t\"initial_date\": \"YYYY-MM-DD\"\n\t\t\t\t\t\"n\": // integer\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"monthly_pattern\"\n\t\t\t\t\t\"day\": // integer 1-31 for nth day of month, or -1 for last day of each month\n\t\t\t\t\t\"months\": // array of 12 booleans. each boolean is true if that month is enabled. if the user doesn't specify which months are enabled, assume all of them are enabled\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"annually_pattern\"\n\t\t\t\t\t\"month\": // integer 1-12\n\t\t\t\t\t\"day\": // integer 1-31\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"nth_weekday_of_months_pattern\"\n\t\t\t\t\t\"day_of_week\": // integer 1-7\n\t\t\t\t\t\"weeks_of_month\": // \"last\" for last appearance of that weekday in the month. or an array of 4 booleans where each boolean represents if the pattern triggers on that week of the month. \"2nd and 3rd friday of each month\" would be [false, true, true, false].\n\t\t\t\t\t\"months\": // array of 12 booleans for if the pattern is enabled for that month.\n\t\t\t\t}\n\t\t    \"time\": \"HH:MM\" // OPTIONAL\n\t\t    \"range\": // \"YYYY-MM-DD:YYYY-MM-DD\" bounds for when the pattern should start and end, or if no bounds are given assume starts today and has no end so its \"YYYY-MM-DD:null\", or give an integer for n times total across this instance.\n\t    }\n\t]\n\t\"work_sessions\": [ // OPTIONAL\n\t\t// array of objects with types \"event_instance\" and \"event_pattern\"\n\t\t// times when the user has said they want to work on the task\n\t]\n}\n\nEvent JSON:\n{\n\t\"type\": \"event\"\n\t\"name\": // use sentence case\n\t\"instances\": [ // 2 options\n\t\t{\n\t\t\t\"type\": \"event_instance\"\n\t\t\t\"start_date\": \"YYYY-MM-DD\", must be included if an end time is given\n\t\t\t\"start_time\": \"HH:MM\" // OPTIONAL, include if the start time is explictly known\n\t\t\t\"end_time\": \"HH:MM\" // OPTIONAL, include if the end time is explictly known\n\t\t\t\"different_end_date\": \"YYYY-MM-DD\" // OPTIONAL, include if the event runs 24/7 and ends on a different date than the start date\n\t\t}\n\t\t{\n\t\t\t\"type\": \"event_pattern\"\n\t\t\t\"start_date_pattern\": // object with type every_n_days_pattern, monthly_pattern, annually_pattern, or nth_weekday_of_months_pattern \n\t\t\t\"start_time\": \"HH:MM\" // OPTIONAL\n\t\t\t\"end_time\": \"HH:MM\" // OPTIONAL\n\t\t\t\"different_end_date_offset\": // OPTIONAL, integer for how many days each occurrence of the event ends after it starts. only include if the event ends on a different day than it starts. can only be included if end_time is also given\n\t\t\t\"range\": // \"YYYY-MM-DD:YYYY-MM-DD\" or integer number of times\n\t\t}\n\t]\n}\n\nReminder JSON:\n{\n\t\"type\": \"reminder\"\n\t\"name\": // use sentence case\n\t\"instances\": [\n\t\t{\n\t\t\t\"type\": \"reminder_instance\"\n\t\t\t\"date\": \"YYYY-MM-DD\"\n\t\t    \"time\": \"HH:MM\"\n\t\t}\n\t\t{\n\t\t\t\"type\": \"reminder_pattern\"\n\t\t\t\"date\": // object with type every_n_days_pattern, monthly_pattern, annually_pattern, or nth_weekday_of_months_pattern \n\t\t    \"time\": \"HH:MM\"\n\t\t}\n\t]\n}\n\nDon't forget to have commas in the JSON. You will return nothing but an array of objects of type task, event, or reminder. Don't include useless stuff in the name, like \"!!!\" or \"due\"`\n\nlet fileDescriptionPrompt = `You are an AI that takes in files and describes them with as much detail as possible. Do not include your thoughts, only the description. Use as much detail as possible, especially regarding dates and times. If the file contains text, extract 100% of the text. A different AI handles the user's prompt, but it may be helpful context for you. Your job is not to handle the user's request, only to describe the files.`;\n\nlet titleFormatterPrompt = `You are an AI that takes in a title of tasks, events, and reminders, and formats them to be more readable. Each title should be in sentence case. Remove unhelpful words like \"!!!\" or \"due\" that don't add to the meaning of the title. Many titles are already correct and don't need to be changed. Do not include your thoughts, only the formatted titles in a JSON array.`;\n\nfunction createPromptWithFileDescription(userPrompt, descriptionOfFiles) {\n    return `The user provided some files as context for their prompt. Here is a description of the files:\n${descriptionOfFiles}\n\nUser prompt:\n${userPrompt}`;\n}\n\nasync function callGeminiModel(modelName, userPrompt, env, fileArray=[], system_prompt=systemPrompt, reasoning) {\n    console.log(\"Calling Gemini model\");\n    console.log(userPrompt);\n    if (!Object.values(MODELS.GEMINI_MODELS).includes(modelName)) {\n        throw new Error('Unsupported Gemini model: ' + modelName);\n    }\n    try {\n        const parts = [{ text: userPrompt }];\n        \n        // Add files to the parts array\n        if (fileArray && fileArray.length > 0) {\n            for (const file of fileArray) {\n                const base64Data = file.data;\n                const mediaType = file.mimeType || 'application/octet-stream';\n                const fileName = file.name;\n                \n                if (mediaType.startsWith('image/')) {\n                    // Add image using inline data\n                    parts.push({\n                        inlineData: {\n                            mimeType: mediaType,\n                            data: base64Data\n                        }\n                    });\n                } else if (mediaType.startsWith('text/')) {\n                    try {\n                        // Decode text file and add as text\n                        const textContent = atob(base64Data);\n                        parts.push({\n                            text: `File: ${fileName}\\nContent:\\n${textContent}`\n                        });\n                    } catch (err) {\n                        console.error('Error decoding base64 text file:', err);\n                    }\n                } else if (mediaType.startsWith('application/pdf')) {\n                    // Add PDF using inline data\n                    parts.push({\n                        inlineData: {\n                            mimeType: mediaType,\n                            data: base64Data\n                        }\n                    });\n                } else {\n                    console.log(\"Unsupported media type for Gemini: \" + mediaType);\n                }\n            }\n        }\n        \n        const body = {\n            model: modelName,\n            system_instruction: { parts: [{ text: system_prompt }] },\n            contents: [{ parts }],\n        };\n\n        if (reasoning) {\n            body.generation_config = {\n                thinking_config: {\n                    thinking_budget: -1 // let the model decide how long to think for\n                }\n            }\n        } else {\n            body.generation_config = {\n                reasoning_config: {\n                    reasoning_budget: 0 // no thinking\n                }\n            }\n        }\n\n        const genRes = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${env.GEMINI_API_KEY}`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(body),\n        });\n        console.log(\"Gemini response: \");\n        const genJson = await genRes.json();\n        console.log(genJson);\n        const outParts = genJson?.candidates?.[0]?.content?.parts || [];\n        return outParts.map(p => p.text || '').join('');\n    } catch (err) {\n        console.error('Gemini model error:', err);\n        return '';\n    }\n}\n\nasync function callCerebrasModel(modelName, userPrompt, env) {\n    console.log(\"Calling Cerebras model\");\n    if (modelName !== 'qwen-3-32b') {\n        throw new Error('Unsupported Cerebras model: ' + modelName);\n    }\n    try {\n        const cerebrasRequest = {\n            model: modelName,\n            messages: [\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt },\n            ],\n            max_tokens: 8192,\n            stream: false,\n        };\n        const resp = await fetch('https://api.cerebras.ai/v1/chat/completions', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${env.CEREBRAS_API_KEY}`,\n            },\n            body: JSON.stringify(cerebrasRequest),\n        });\n        const result = await resp.json();\n        return result.choices?.[0]?.message?.content || '';\n    } catch (err) {\n        console.error('Cerebras model error:', err);\n        return '';\n    }\n}\n\nasync function callAnthropicModel(modelName, userPrompt, env, fileArray=[], system_prompt=systemPrompt) {\n    if (!Object.values(MODELS.ANTHROPIC_MODELS).includes(modelName)) {\n        throw new Error('Unsupported Anthropic model: ' + modelName);\n    }\n\n    // Prepare the content array\n    const content = [\n        {\n            type: 'text',\n            text: userPrompt\n        }\n    ];\n\n    // Add files as base64 encoded content\n    if (fileArray && fileArray.length > 0) {\n        for (const file of fileArray) {\n            // Files are already base64 encoded from frontend\n            const base64Data = file.data;\n            const mediaType = file.mimeType || 'application/octet-stream';\n            const fileName = file.name;\n            // Only add images for now (following the test.sh pattern)\n            if (mediaType.startsWith('image/')) {\n                content.push({\n                    type: 'image',\n                    source: {\n                        type: 'base64',\n                        media_type: mediaType,\n                        data: base64Data\n                    }\n                });\n            } else if (mediaType.startsWith('text/')) {\n                try {\n                    const textContent = atob(base64Data);\n                    content.push({\n                        type: 'text',\n                        text: `File: ${fileName}\\nContent:\\n${textContent}`\n                    });\n                } catch (err) {\n                    console.error('Error decoding base64 text file:', err);\n                }\n            } else if (mediaType.startsWith('application/pdf')) {\n                content.push({\n                    type: 'document',\n                    source: {\n                        type: 'base64',\n                        media_type: mediaType,\n                        data: base64Data\n                    }\n                });\n            } else {\n                console.log(\"Unsupported media type: \" + mediaType);\n            }\n        }\n    }\n\n    // Make the API call\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n        method: 'POST',\n        headers: {\n            'x-api-key': env.ANTHROPIC_API_KEY,\n            'anthropic-version': '2023-06-01',\n            'content-type': 'application/json'\n        },\n        body: JSON.stringify({\n            model: modelName,\n            max_tokens: 1024,\n            system: system_prompt,\n            messages: [\n                {\n                    role: 'user',\n                    content: content\n                }\n            ]\n        })\n    });\n\n    if (!response.ok) {\n        const errorText = await response.text();\n        console.log(\"Anthropic API error: \" + errorText);\n        return SEND({\n            error: 'Failed to call Anthropic model: ' + response.statusText\n        }, 471);\n    }\n\n    const result = await response.json();\n    console.log(\"Anthropic result: \");\n    console.log(result.content[0].text);\n    \n    // Handle the response structure: result.content is an array of content objects\n    if (result.content && Array.isArray(result.content) && result.content.length > 0) {\n        // Find the first text content block\n        const textContent = result.content.find(item => item.type === 'text');\n        if (textContent && textContent.text) {\n            return textContent.text;\n        }\n    }\n    \n    return '';\n}\n\nasync function callGroqModel(modelName, userPrompt, env, fileArray=[]) {\n    console.log(\"Calling Groq model\");\n    if (modelName === 'qwen/qwen3-32b') {\n        if (fileArray && fileArray.length > 0) {\n            // add files to prompt\n            return SEND({\n                error: 'Groq qwen3-32b does not support files.'\n            }, 473);\n        }\n        try {\n            const groqRequest = {\n                model: modelName,\n                messages: [\n                    { role: 'system', content: systemPrompt },\n                    { role: 'user', content: userPrompt },\n                ],\n                max_tokens: 8192,\n                stream: false,\n                reasoning_format: 'raw' // we don't want to see the model thinking\n            };\n\n            const groqResp = await fetch('https://api.groq.com/openai/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    Authorization: `Bearer ${env.GROQ_API_KEY}`,\n                },\n                body: JSON.stringify(groqRequest),\n            });\n            const groqResult = await groqResp.json();\n            return groqResult.choices?.[0]?.message?.content || '';\n        } catch (err) {\n            console.error('Groq model error:', err);\n            return '';\n        }\n    } else if (modelName === 'meta-llama/llama-4-maverick-17b-128e-instruct') {\n\n    } else {\n        return SEND({\n            error: 'Unsupported Groq model: ' + modelName\n        }, 474);\n    }\n}\n\nasync function callAiModel(userPrompt, fileArray, env) {\n    try {\n        let content;\n        // chain is the whole reasoning process\n        // each object has either:\n        //   model, type of prompt, response, and reasoning boolean\n        //   or\n        //   reroute_to_model (we failed to connect, so this is the next model to try)\n        //   or\n        //   user_prompt (the user's prompt)\n        //   or\n        //   user_attachments\n        // we want to include reroutes in the chain\n        let chain = [];\n\n        // user prompt and file array are added to the chain on the frontend\n\n        if (Array.isArray(fileArray) && fileArray.length > 0) {\n            let descriptionOfFiles;\n            // STEP 1: get description of files\n            // 1st choice - gemini flash\n            descriptionOfFiles = await callGeminiModel(MODELS.GEMINI_MODELS.flash, userPrompt, env, fileArray, fileDescriptionPrompt, false);\n\n            if (descriptionOfFiles && descriptionOfFiles.trim() !== '') {\n                chain.push({\n                    model: MODELS.GEMINI_MODELS.flash,\n                    type_of_prompt: 'file_description',\n                    response: descriptionOfFiles,\n                    reasoning: false\n                });\n            } else {\n                chain.push({\n                    reroute_to_model: MODELS.ANTHROPIC_MODELS.sonnet\n                });\n                // 2nd choice - claude sonnet\n                // Use Anthropic Claude for files (vision support)\n                descriptionOfFiles = await callAnthropicModel(MODELS.ANTHROPIC_MODELS.sonnet, userPrompt, env, fileArray, fileDescriptionPrompt);\n\n                if (descriptionOfFiles && descriptionOfFiles.trim() !== '') {\n                    chain.push({\n                        model: MODELS.ANTHROPIC_MODELS.sonnet,\n                        type_of_prompt: 'file_description',\n                        response: descriptionOfFiles,\n                        reasoning: false\n                    });\n                } else {\n                    // unable to comprehend files\n                    return SEND({\n                        error: 'Unable to comprehend files.'\n                    }, 475);\n                }\n            }\n\n            // STEP 2: parse json including file descriptions context\n            let newPrompt;\n            if (userPrompt.trim() === '') {\n                // no user prompt, so just use the files to generate a new prompt\n                newPrompt = \"I attached some files to my prompt. Here is a description of the files: \" + descriptionOfFiles;\n            } else {\n                newPrompt = createPromptWithFileDescription(userPrompt, descriptionOfFiles);\n            }\n\n            // use Gemini Flash Reasoning because file tasks are generally the hardest kind of requests\n            content = await callGeminiModel(MODELS.GEMINI_MODELS.flash, newPrompt, env, fileArray, systemPrompt, true);\n\n            if (content && content.trim() !== '') {\n                chain.push({\n                    model: MODELS.GEMINI_MODELS.flash,\n                    type_of_prompt: 'convert_files_to_entities',\n                    response: content,\n                    reasoning: true\n                });\n            } else {\n                chain.push({\n                    reroute_to_model: MODELS.CEREBRAS_MODELS.qwen3\n                });\n                // 2nd choice - Cerebras\n                content = await callCerebrasModel(MODELS.CEREBRAS_MODELS.qwen3, newPrompt, env);\n                if (content && content.trim() !== '') {\n                    chain.push({\n                        model: MODELS.CEREBRAS_MODELS.qwen3,\n                        type_of_prompt: 'convert_files_to_entities',\n                        response: content,\n                        reasoning: false\n                    });\n                } else {\n                    chain.push({\n                        reroute_to_model: MODELS.GROQ_MODELS.qwen3\n                    });\n                    // 3rd choice - Groq\n                    content = await callGroqModel(MODELS.GROQ_MODELS.qwen3, newPrompt, env);\n                    if (content && content.trim() !== '') {\n                        chain.push({\n                            model: MODELS.GROQ_MODELS.qwen3,\n                            type_of_prompt: 'convert_files_to_entities',\n                            response: content,\n                            reasoning: false\n                        });\n                    } else {\n                        return SEND({\n                            error: 'Failed to connect to any AI model.'\n                        }, 467);\n                    }\n                }\n            }\n        } else {\n            // Use Qwen for text-only requests\n\n            // 1st choice - Cerebras\n            content = await callCerebrasModel('qwen-3-32b', userPrompt, env);\n            if (content && content.trim() !== '') {\n                chain.push({\n                    model: MODELS.CEREBRAS_MODELS.qwen3,\n                    type_of_prompt: 'convert_text_to_entities',\n                    response: content,\n                    reasoning: false\n                });\n            } else {\n                chain.push({\n                    reroute_to_model: MODELS.GROQ_MODELS.qwen3\n                });\n                // 2nd choice - Groq\n                content = await callGroqModel('qwen/qwen3-32b', userPrompt, env);\n                if (content && content.trim() !== '') {\n                    chain.push({\n                        model: MODELS.GROQ_MODELS.qwen3,\n                        type_of_prompt: 'convert_text_to_entities',\n                        response: content,\n                        reasoning: false\n                    });\n                } else {\n                    chain.push({\n                        reroute_to_model: MODELS.GEMINI_MODELS.flash\n                    });\n                    // 3rd choice - Gemini\n                    content = await callGeminiModel(MODELS.GEMINI_MODELS.flash, userPrompt, env, fileArray, systemPrompt, false);\n                    if (content && content.trim() !== '') {\n                        chain.push({\n                            model: MODELS.GEMINI_MODELS.flash,\n                            type_of_prompt: 'convert_text_to_entities',\n                            response: content,\n                            reasoning: false\n                        });\n                    } else {\n                        return SEND({\n                            error: 'Failed to connect to any AI model.'\n                        }, 467);\n                    }\n                }\n            }\n        }\n\n        return {\n            aiOutput: content,\n            chain: chain\n        };\n    } catch (err) {\n        console.error('callAiModel error:', err);\n        return SEND({\n            error: 'Error in callAiModel: ' + err.message\n        }, 467);\n    }\n}\n\nexport default {\n    async fetch(request, env) {\n        const url = new URL(request.url);\n\n        if (request.method === 'OPTIONS') {\n            return SEND(null, 204);\n        }\n\n        switch (url.pathname) {\n            case '/signup':\n                {\n                    if (request.method !== 'POST') return SEND({\n                        error: 'Method not allowed'\n                    }, 405);\n\n                    try {\n                        const {\n                            email,\n                            password\n                        } = await request.json();\n\n                        if (!email || !password) {\n                            return SEND({\n                                error: 'Email and password are required.'\n                            }, 400);\n                        }\n                        if (password.length < 8) {\n                            return SEND({\n                                error: 'Password must be at least 8 characters long.'\n                            }, 400);\n                        }\n\n                        const existingUser = await env.DB.prepare('SELECT user_id, email, verified_email, data FROM users WHERE email = ?').bind(email).first();\n                        if (existingUser && existingUser.verified_email) {\n                            return SEND({\n                                error: 'User with this email already exists.'\n                            }, 409);\n                        }\n\n                        const salt = crypto.randomUUID().replaceAll('-', '');\n                        const password_hash = await hash(password, salt);\n                        const verification_code = Math.floor(100000 + Math.random() * 900000).toString();\n                        const verification_code_expires_at = Date.now() + (10 * 60 * 1000); // 10 minutes\n\n                        let user_id;\n\n                        if (existingUser) { // User exists but is not verified\n                            // Use the existing user_id\n                            user_id = existingUser.user_id;\n                            \n                            const userData = JSON.parse(existingUser.data || '{}');\n                            userData.verification_code = verification_code;\n                            userData.verification_code_expires_at = verification_code_expires_at;\n                            await env.DB.prepare(\n                                `UPDATE users SET password_hash = ?, salt = ?, data = ? WHERE email = ?`\n                            ).bind(password_hash, salt, JSON.stringify(userData), email).run();\n                        } else {\n                            user_id = crypto.randomUUID().replaceAll('-', '');\n                            user_id = user_id.slice(0, 8);\n                            const userData = {\n                                verification_code,\n                                verification_code_expires_at\n                            };\n                            await env.DB.prepare(\n                                `INSERT INTO users (user_id, email, verified_email, data, dataspec, usage, timestamp, plan, payment_times, login_attempts, provider, password_hash, salt)\n                                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n                            ).bind(\n                                user_id,\n                                email,\n                                false, // verified_email\n                                JSON.stringify(userData), // data\n                                1, // dataspec\n                                0, // usage\n                                Date.now(), // timestamp\n                                'free', // plan\n                                '[]', // payment_times\n                                '[]', // login_attempts\n                                'email', // provider\n                                password_hash,\n                                salt\n                            ).run();\n                        }\n\n                        const emailContent = `Your verification code is: ${verification_code}`;\n                        await sendEmail(env.SENDGRID_API_KEY, email, 'Verify your email for Scribblit', emailContent);\n\n                        return SEND({\n                            message: 'Verification code sent to your email.',\n                            id: user_id\n                        });\n\n                    } catch (err) {\n                        console.error('Signup error:', err);\n                        return SEND({\n                            error: 'Failed to process signup request.'\n                        }, 500);\n                    }\n                }\n\n            case '/verify-email':\n                {\n                    if (request.method !== 'POST') return SEND({\n                        error: 'Method not allowed'\n                    }, 405);\n                    try {\n                        const {\n                            email,\n                            code\n                        } = await request.json();\n                        if (!email || !code) {\n                            return SEND({\n                                error: 'Email and verification code are required.'\n                            }, 400);\n                        }\n\n                        const user = await env.DB.prepare('SELECT user_id, data, verified_email FROM users WHERE email = ?').bind(email).first();\n\n                        if (!user) {\n                            return SEND({\n                                error: 'User not found.'\n                            }, 404);\n                        }\n\n                        if (user.verified_email) {\n                            return SEND({\n                                error: 'Email is already verified.'\n                            }, 400);\n                        }\n\n                        const userData = JSON.parse(user.data);\n\n                        if (!userData.verification_code_expires_at || Date.now() > userData.verification_code_expires_at) {\n                            return SEND({\n                                error: 'Verification code has expired.'\n                            }, 400);\n                        }\n\n                        if (userData.verification_code !== code) {\n                            return SEND({\n                                error: 'Invalid verification code.'\n                            }, 400);\n                        }\n\n                        delete userData.verification_code;\n                        delete userData.verification_code_expires_at;\n\n                        await env.DB.prepare(\n                            'UPDATE users SET verified_email = ?, data = ? WHERE email = ?'\n                        ).bind(true, \"{}\", email).run();\n    \n                        const token = await generateToken(email, env.SECRET_KEY);\n                        return SEND({\n                            token,\n                            id: user.user_id\n                        });\n\n                    } catch (err) {\n                        console.error('Email verification error:', err);\n                        return SEND({\n                            error: 'Failed to process email verification.'\n                        }, 500);\n                    }\n                }\n\n            case '/login':\n                {\n                    if (request.method !== 'POST') return SEND({\n                        error: 'Method not allowed'\n                    }, 405);\n\n                    try {\n                        const {\n                            email,\n                            password\n                        } = await request.json();\n                        if (!email || !password) {\n                            return SEND({\n                                error: 'Email and password are required.'\n                            }, 400);\n                        }\n\n                        const user = await env.DB.prepare('SELECT user_id, password_hash, salt, verified_email FROM users WHERE email = ?').bind(email).first();\n                        if (!user) {\n                            return SEND({\n                                error: 'Invalid credentials.'\n                            }, 401);\n                        }\n\n                        if (!user.verified_email) {\n                            return SEND({\n                                error: 'Please verify your email before logging in.'\n                            }, 401);\n                        }\n\n                        const hashedPassword = await hash(password, user.salt);\n                        if (user.password_hash !== hashedPassword) {\n                            return SEND({\n                                error: 'Invalid credentials.'\n                            }, 401);\n                        }\n\n                        const token = await generateToken(email, env.SECRET_KEY);\n                        return SEND({\n                            token,\n                            id: user.user_id\n                        });\n\n                    } catch (err) {\n                        console.error('Login error:', err);\n                        return SEND({\n                            error: 'Failed to process login request.'\n                        }, 500);\n                    }\n                }\n\n            case '/get-user':\n                {\n                    if (request.method !== 'GET') return SEND({\n                        error: 'Method Not Allowed'\n                    }, 405);\n\n                    try {\n                        const authHeader = request.headers.get('Authorization');\n                        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n                            return SEND({\n                                error: 'Authorization header is missing or invalid.'\n                            }, 401);\n                        }\n\n                        const token = authHeader.substring(7); // Remove 'Bearer '\n                        const email = await verifyToken(token, env.SECRET_KEY);\n\n                        if (!email) {\n                            return SEND({\n                                error: 'Invalid or expired token.'\n                            }, 401);\n                        }\n\n                        const userResult = await env.DB.prepare(\n                            'SELECT user_id, email, data, dataspec, usage, timestamp, plan, payment_times FROM users WHERE email = ?'\n                        ).bind(email).first();\n\n                        if (!userResult) {\n                            return SEND({\n                                error: 'User not found.'\n                            }, 404);\n                        }\n\n                        const userJson = {\n                            _type: 'User',\n                            userId: userResult.user_id,\n                            email: userResult.email,\n                            data: userResult.data, // This is a stringified JSON\n                            dataspec: userResult.dataspec,\n                            usage: userResult.usage,\n                            timestamp: userResult.timestamp,\n                            plan: userResult.plan,\n                            paymentTimes: JSON.parse(userResult.payment_times),\n                        };\n\n                        const newToken = await generateToken(email, env.SECRET_KEY);\n\n                        return SEND({\n                            user: userJson,\n                            token: newToken\n                        });\n\n                    } catch (err) {\n                        console.error('Get user error:', err);\n                        return SEND({\n                            error: 'Failed to get user data.'\n                        }, 500);\n                    }\n                }\n\n            case '/update-user':\n                {\n                    if (request.method !== 'POST') return SEND({ error: 'Method Not Allowed' }, 405);\n\n                    try {\n                        const authHeader = request.headers.get('Authorization');\n                        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n                            return SEND({ error: 'Authorization header is missing or invalid.' }, 401);\n                        }\n                        const token = authHeader.substring(7);\n                        const email = await verifyToken(token, env.SECRET_KEY);\n                        if (!email) {\n                            return SEND({ error: 'Invalid or expired token.' }, 401);\n                        }\n\n                        const {\n                            data,\n                            dataspec,\n                            timestamp,\n                        } = await request.json();\n\n                        if (typeof data !== 'string' || typeof dataspec !== 'number' || typeof timestamp !== 'number') {\n                            return SEND({ error: 'Invalid user data.' }, 400);\n                        }\n\n                        await env.DB.prepare(\n                            `UPDATE users SET data = ?, dataspec = ?, timestamp = ? WHERE email = ?`\n                        ).bind(\n                            data,\n                            dataspec,\n                            timestamp,\n                            email\n                        ).run();\n\n                        return SEND({ success: true });\n                    } catch (err) {\n                        console.error('Update user error:', err);\n                        return SEND({ error: 'Failed to update user data.' }, 500);\n                    }\n                }\n\n            case '/send-email':\n                if (request.method !== 'POST') {\n                    return SEND({\n                        error: 'Method Not Allowed'\n                    }, 405);\n                }\n                try {\n                    const {\n                        to,\n                        subject,\n                        content\n                    } = await request.json();\n                    await sendEmail(env.SENDGRID_API_KEY, to, subject, content);\n                    return SEND('Email sent', 200);\n                } catch (err) {\n                    return SEND(err.message || err.toString(), 500);\n                }\n\n            case '/auth/google':\n                {\n                    if (request.method !== 'GET') {\n                        return SEND({ error: 'Method not allowed' }, 405);\n                    }\n                    \n                    const state = crypto.randomUUID();\n                    const googleAuthUrl = 'https://accounts.google.com/o/oauth2/v2/auth?' +\n                        `response_type=code&` +\n                        `client_id=${env.GOOGLE_CLIENT_ID}&` +\n                        `redirect_uri=${encodeURIComponent('https://' + SERVER_DOMAIN + '/auth/google/callback')}&` +\n                        `scope=${encodeURIComponent('openid email')}&` +\n                        `state=${state}`;\n                    \n                    return Response.redirect(googleAuthUrl, 302);\n                }\n\n            case '/auth/google/callback':\n                {\n                    if (request.method !== 'GET') {\n                        return SEND({ error: 'Method not allowed' }, 405);\n                    }\n                    \n                    try {\n                        const { searchParams } = new URL(request.url);\n                        const code = searchParams.get('code');\n                        const error = searchParams.get('error');\n                        \n                        if (error) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=oauth_error`, 302);\n                        }\n                        \n                        if (!code) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=no_code`, 302);\n                        }\n                        \n                        // Exchange code for access token\n                        const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/x-www-form-urlencoded',\n                            },\n                            body: new URLSearchParams({\n                                code,\n                                client_id: env.GOOGLE_CLIENT_ID,\n                                client_secret: env.GOOGLE_CLIENT_SECRET,\n                                redirect_uri: 'https://' + SERVER_DOMAIN + '/auth/google/callback',\n                                grant_type: 'authorization_code',\n                            }),\n                        });\n                        \n                        const tokenData = await tokenResponse.json();\n                        \n                        if (!tokenData.access_token) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=token_error`, 302);\n                        }\n                        \n                        // Get user info from Google\n                        const userResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n                            headers: {\n                                'Authorization': `Bearer ${tokenData.access_token}`,\n                            },\n                        });\n                        \n                        const googleUser = await userResponse.json();\n                        \n                        if (!googleUser.email) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=no_email`, 302);\n                        }\n                        \n                        // Check if user exists\n                        let user = await env.DB.prepare('SELECT user_id, email, verified_email, data FROM users WHERE email = ?')\n                            .bind(googleUser.email).first();\n                        \n                        let user_id;\n                        \n                        if (user) {\n                            // Update existing user to use Google OAuth\n                            user_id = user.user_id;\n                            await env.DB.prepare(\n                                'UPDATE users SET provider = ?, provider_id = ?, verified_email = ? WHERE email = ?'\n                            ).bind('google', googleUser.id, true, googleUser.email).run();\n                        } else {\n                            // Create new user\n                            user_id = crypto.randomUUID().replaceAll('-', '').slice(0, 8);\n                            await env.DB.prepare(\n                                `INSERT INTO users (user_id, email, verified_email, data, dataspec, usage, timestamp, plan, payment_times, login_attempts, provider, provider_id)\n                                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n                            ).bind(\n                                user_id,\n                                googleUser.email,\n                                true, // verified_email\n                                '{}', // data\n                                1, // dataspec\n                                0, // usage\n                                Date.now(), // timestamp\n                                'free', // plan\n                                '[]', // payment_times\n                                '[]', // login_attempts\n                                'google', // provider\n                                googleUser.id // provider_id\n                            ).run();\n                        }\n                        \n                        // Generate JWT token\n                        const token = await generateToken(googleUser.email, env.SECRET_KEY);\n                        \n                        // Redirect to frontend with token\n                        return Response.redirect(`https://${PAGES_DOMAIN}/?token=${token}&id=${user_id}`, 302);\n                        \n                    } catch (err) {\n                        console.error('Google OAuth callback error:', err);\n                        return Response.redirect(`https://${PAGES_DOMAIN}/?error=callback_error`, 302);\n                    }\n                }\n\n            case '/test-email-integration':\n                if (request.method !== 'GET') {\n                    return SEND({\n                        error: 'Method Not Allowed'\n                    }, 405);\n                }\n                try {\n                    await sendEmail(\n                        env.SENDGRID_API_KEY,\n                        'liamtswayne@gmail.com',\n                        'Test Integration',\n                        'This is a test email from your Cloudflare Worker. If you see this, the SendGrid integration is working.'\n                    );\n                    return SEND('Test email sent', 200);\n                } catch (err) {\n                    return SEND(err.message || err.toString(), 500);\n                }\n\n            case '/ai/parse':\n                {\n                    if (request.method !== 'POST') return SEND({ error: 'Method Not Allowed' }, 405);\n                    try {\n                        const data = await request.json();\n                        const userText = data.prompt;\n                        const fileArray = data.fileArray;\n\n                        if (userText == null || userText.length === 0) {\n                            return SEND({ error: 'Empty request body' }, 400);\n                        }\n\n                        const { aiOutput, chain } = await callAiModel(userText, fileArray, env);\n                        console.log(\"AI output: \" + aiOutput);\n                        return SEND({\n                            aiOutput: aiOutput,\n                            chain: chain\n                        }, 200);\n                    } catch (err) {\n                        console.error('AI parse error:', err);\n                        return SEND({ error: 'Failed to process AI request: ' + err.message }, 563);\n                    }\n                }\n\n            default:\n                return SEND({\n                    error: 'Endpoint not found'\n                }, 404);\n        }\n    }\n};\n\nasync function sendEmail(apiKey, to, subject, content) {\n    const msg = {\n        personalizations: [{\n            to: [{\n                email: to\n            }]\n        }],\n        from: {\n            email: 'hello@scribbl.it'\n        },\n        subject: subject,\n        content: [{\n            type: 'text/plain',\n            value: content\n        }]\n    };\n\n    const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n        method: 'POST',\n        headers: {\n            Authorization: `Bearer ${apiKey}`,\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(msg)\n    });\n\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`SendGrid API error: ${errorText}`);\n    }\n}"],
  "mappings": "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",
  "names": []
}
