{
  "version": 3,
  "sources": ["../../../main.js"],
  "sourceRoot": "/Volumes/Liam's Works/Programming/Scribblit/private_v2/.wrangler/tmp/deploy-PotUzs",
  "sourcesContent": ["const SERVER_DOMAIN_OLD = 'scribblit-production.unrono.workers.dev';\nconst SERVER_DOMAIN = 'app.scribbl.it';\nconst OLD_PAGES_DOMAIN = 'scribblit2.pages.dev';\nconst PAGES_DOMAIN = 'scribbl.it';\n\nfunction SEND(data, status = 200, headers = {}) {\n    const corsHeaders = {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET, HEAD, POST, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    };\n\n    if (typeof data === 'object' && data !== null) {\n        data = JSON.stringify(data);\n        if (!headers['Content-Type']) {\n            headers['Content-Type'] = 'application/json';\n        }\n    }\n\n    return new Response(data, {\n        status,\n        headers: {\n            ...corsHeaders,\n            ...headers\n        },\n    });\n}\n\nasync function hash(password, salt = \"\") {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(password + salt);\n    const digest = await crypto.subtle.digest('SHA-256', data);\n    return btoa(String.fromCharCode(...new Uint8Array(digest)));\n}\n\nasync function verifyToken(token, secret_key) {\n    try {\n        const [payloadBase64, signatureBase64] = token.split('.');\n        const payload = JSON.parse(atob(payloadBase64));\n\n        if (payload.exp && Date.now() / 1000 > payload.exp) {\n            return null; // Token expired\n        }\n\n        const signature = Uint8Array.from(atob(signatureBase64), c => c.charCodeAt(0));\n        const encoder = new TextEncoder();\n        const key = await crypto.subtle.importKey(\n            'raw',\n            encoder.encode(secret_key), {\n                name: 'HMAC',\n                hash: 'SHA-256'\n            },\n            false,\n            ['verify']\n        );\n        const data = encoder.encode(JSON.stringify(payload));\n        const isValid = await crypto.subtle.verify('HMAC', key, signature, data);\n        if (!isValid) {\n            return null;\n        }\n        return payload.email;\n    } catch (err) {\n        return null;\n    }\n}\n\nasync function generateToken(email, secret_key) {\n    const payload = {\n        email,\n        exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 30) // 30 days\n    };\n    const payloadBase64 = btoa(JSON.stringify(payload));\n    const encoder = new TextEncoder();\n    const key = await crypto.subtle.importKey(\n        'raw',\n        encoder.encode(secret_key), {\n            name: 'HMAC',\n            hash: 'SHA-256'\n        },\n        false,\n        ['sign']\n    );\n    const data = encoder.encode(JSON.stringify(payload));\n    const signature = await crypto.subtle.sign('HMAC', key, data);\n    const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signature)));\n    return `${payloadBase64}.${signatureBase64}`;\n}\n\nconst systemPrompt = `You are an AI that takes in user input and converts it to tasks, events, and reminders JSON. If something has to be done *by* a certain date/time but can be done before then, it is a task. If something has to be done at a specific date/time and cannot be done before then, it is an event. It is possible for an event to have only a start time if the end time is unknown. A reminder is a special case of something insignificant to be reminded of at a specific time and date. Only include OPTIONAL fields if the user specified the information needed for that field.\n\nTask JSON:\n{\n    \"type\": \"task\"\n    \"name\": // use sentence case  \n    \"instances\": [ // 2 options\n\t    {\n\t\t    \"type\": \"due_date_instance\"\n\t\t    \"date\": \"YYYY-MM-DD\" // OPTIONAL. if a time a is given then assume the due date is today\n\t\t    \"time\": \"HH:MM\"// OPTIONAL. if it's due today and the current time is past noon assume numbers below 12 are pm.\n\t    }\n\t    {\n\t\t    \"type\": \"due_date_pattern\"\n\t\t    \"pattern\": // 4 options\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"every_n_days_pattern\"\n\t\t\t\t\t\"initial_date\": \"YYYY-MM-DD\"\n\t\t\t\t\t\"n\": // integer\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"monthly_pattern\"\n\t\t\t\t\t\"day\": // integer 1-31 for nth day of month, or -1 for last day of each month\n\t\t\t\t\t\"months\": // array of 12 booleans. each boolean is true if that month is enabled. if the user doesn't specify which months are enabled, assume all of them are enabled\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"annually_pattern\"\n\t\t\t\t\t\"month\": // integer 1-12\n\t\t\t\t\t\"day\": // integer 1-31\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"nth_weekday_of_months_pattern\"\n\t\t\t\t\t\"day_of_week\": // integer 1-7\n\t\t\t\t\t\"weeks_of_month\": // \"last\" for last appearance of that weekday in the month. or an array of 4 booleans where each boolean represents if the pattern triggers on that week of the month. \"2nd and 3rd friday of each month\" would be [false, true, true, false].\n\t\t\t\t\t\"months\": // array of 12 booleans for if the pattern is enabled for that month.\n\t\t\t\t}\n\t\t    \"time\": \"HH:MM\" // OPTIONAL\n\t\t    \"range\": // \"YYYY-MM-DD:YYYY-MM-DD\" bounds for when the pattern should start and end, or if no bounds are given assume starts today and has no end so its \"YYYY-MM-DD:null\", or give an integer for n times total across this instance.\n\t    }\n\t]\n\t\"work_sessions\": [ // OPTIONAL\n\t\t// array of objects with types \"event_instance\" and \"event_pattern\"\n\t\t// times when the user has said they want to work on the task\n\t]\n}\n\nEvent JSON:\n{\n\t\"type\": \"event\"\n\t\"name\": // use sentence case\n\t\"instances\": [ // 2 options\n\t\t{\n\t\t\t\"type\": \"event_instance\"\n\t\t\t\"start_date\": \"YYYY-MM-DD\", must be included if an end time is given\n\t\t\t\"start_time\": \"HH:MM\" // OPTIONAL, include if the start time is explictly known\n\t\t\t\"end_time\": \"HH:MM\" // OPTIONAL, include if the end time is explictly known\n\t\t\t\"different_end_date\": \"YYYY-MM-DD\" // OPTIONAL, include if the event runs 24/7 and ends on a different date than the start date\n\t\t}\n\t\t{\n\t\t\t\"type\": \"event_pattern\"\n\t\t\t\"start_date_pattern\": // object with type every_n_days_pattern, monthly_pattern, annually_pattern, or nth_weekday_of_months_pattern \n\t\t\t\"start_time\": \"HH:MM\" // OPTIONAL\n\t\t\t\"end_time\": \"HH:MM\" // OPTIONAL\n\t\t\t\"different_end_date_offset\": // OPTIONAL, integer for how many days each occurrence of the event ends after it starts. only include if the event ends on a different day than it starts. can only be included if end_time is also given\n\t\t\t\"range\": // \"YYYY-MM-DD:YYYY-MM-DD\" or integer number of times\n\t\t}\n\t]\n}\n\nReminder JSON:\n{\n\t\"type\": \"reminder\"\n\t\"name\": // use sentence case\n\t\"instances\": [\n\t\t{\n\t\t\t\"type\": \"reminder_instance\"\n\t\t\t\"date\": \"YYYY-MM-DD\"\n\t\t    \"time\": \"HH:MM\"\n\t\t}\n\t\t{\n\t\t\t\"type\": \"reminder_pattern\"\n\t\t\t\"date\": // object with type every_n_days_pattern, monthly_pattern, annually_pattern, or nth_weekday_of_months_pattern \n\t\t    \"time\": \"HH:MM\"\n\t\t}\n\t]\n}\n\nDon't forget to have commas in the JSON. You will return nothing but an array of objects of type task, event, or reminder.`\n\nasync function callGeminiModel(modelName, userPrompt, env) {\n    console.log(\"Calling Gemini model\");\n    if (modelName !== 'gemini-2.5-flash-lite-preview-06-17') {\n        throw new Error('Unsupported Gemini model: ' + modelName);\n    }\n    try {\n        const parts = [{ text: userPrompt }];\n        const body = {\n            model: modelName,\n            system_instruction: { parts: [{ text: systemPrompt }] },\n            contents: [{ parts }],\n        };\n        const genRes = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${env.GEMINI_API_KEY}`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(body),\n        });\n        const genJson = await genRes.json();\n        console.log(\"Gemini response: \" + genJson);\n        const outParts = genJson?.candidates?.[0]?.content?.parts || [];\n        return outParts.map(p => p.text || '').join('');\n    } catch (err) {\n        console.error('Gemini model error:', err);\n        return '';\n    }\n}\n\nasync function callCerebrasModel(modelName, userPrompt, env) {\n    console.log(\"Calling Cerebras model\");\n    if (modelName !== 'qwen-3-32b') {\n        throw new Error('Unsupported Cerebras model: ' + modelName);\n    }\n    try {\n        const cerebrasRequest = {\n            model: modelName,\n            messages: [\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt },\n            ],\n            max_tokens: 8192,\n            stream: false,\n        };\n        const resp = await fetch('https://api.cerebras.ai/v1/chat/completions', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${env.CEREBRAS_API_KEY}`,\n            },\n            body: JSON.stringify(cerebrasRequest),\n        });\n        const result = await resp.json();\n        return result.choices?.[0]?.message?.content || '';\n    } catch (err) {\n        console.error('Cerebras model error:', err);\n        return '';\n    }\n}\n\nasync function callAnthropicModel(modelName, userPrompt, env, fileArray=[]) {\n    if (modelName !== 'claude-3-5-haiku-20241022') {\n        throw new Error('Unsupported Anthropic model: ' + modelName);\n    }\n\n    // Prepare the content array\n    const content = [\n        {\n            type: 'text',\n            text: userPrompt\n        }\n    ];\n\n    // Add files as base64 encoded content\n    if (fileArray && fileArray.length > 0) {\n        for (const file of fileArray) {\n            // Files are already base64 encoded from frontend\n            const base64Data = file.data;\n            const mediaType = file.mimeType || 'application/octet-stream';\n            const fileName = file.name;\n            \n            // Only add images for now (following the test.sh pattern)\n            if (mediaType.startsWith('image/')) {\n                content.push({\n                    type: 'image',\n                    source: {\n                        type: 'base64',\n                        media_type: mediaType,\n                        data: base64Data\n                    }\n                });\n            }\n            // For text files, decode base64 and add as text content\n            else if (mediaType.startsWith('text/')) {\n                try {\n                    const textContent = atob(base64Data);\n                    content.push({\n                        type: 'text',\n                        text: `File: ${fileName}\\nContent:\\n${textContent}`\n                    });\n                } catch (err) {\n                    console.error('Error decoding base64 text file:', err);\n                }\n            }\n        }\n    }\n\n    // Make the API call\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n        method: 'POST',\n        headers: {\n            'x-api-key': env.ANTHROPIC_API_KEY,\n            'anthropic-version': '2023-06-01',\n            'content-type': 'application/json'\n        },\n        body: JSON.stringify({\n            model: modelName,\n            max_tokens: 1024,\n            system: systemPrompt,\n            messages: [\n                {\n                    role: 'user',\n                    content: content\n                }\n            ]\n        })\n    });\n\n    if (!response.ok) {\n        const errorText = await response.text();\n        console.log(\"Anthropic API error: \" + errorText);\n        return SEND({\n            error: 'Failed to call Anthropic model: ' + response.statusText\n        }, 471);\n    }\n\n    const result = await response.json();\n    console.log(\"Anthropic result: \" + JSON.stringify(result));\n    \n    // Handle the response structure: result.content is an array of content objects\n    if (result.content && Array.isArray(result.content) && result.content.length > 0) {\n        // Find the first text content block\n        const textContent = result.content.find(item => item.type === 'text');\n        if (textContent && textContent.text) {\n            return textContent.text;\n        }\n    }\n    \n    return '';\n}\n\nasync function callGroqModel(modelName, userPrompt, env) {\n    console.log(\"Calling Groq model\");\n    if (modelName !== 'qwen/qwen3-32b') {\n        throw new Error('Unsupported Groq model: ' + modelName);\n    }\n    try {\n        const groqRequest = {\n            model: modelName,\n            messages: [\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt },\n            ],\n            max_tokens: 8192,\n            stream: false,\n        };\n\n        const groqResp = await fetch('https://api.groq.com/openai/v1/chat/completions', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${env.GROQ_API_KEY}`,\n            },\n            body: JSON.stringify(groqRequest),\n        });\n        const groqResult = await groqResp.json();\n        return groqResult.choices?.[0]?.message?.content || '';\n    } catch (err) {\n        console.error('Groq model error:', err);\n        return '';\n    }\n}\n\nasync function callAiModel(userPrompt, fileArray, env) {\n    try {\n        if (Array.isArray(fileArray) && fileArray.length > 0) {\n            // Use Anthropic Claude for files (vision support)\n            return await callAnthropicModel('claude-3-5-haiku-20241022', userPrompt, env, fileArray);\n        } else {\n            // Use Qwen for text-only requests\n            let content;\n            \n            // 1st choice - Groq Qwen\n            content = await callGroqModel('qwen/qwen3-32b', userPrompt, env);\n            if (content && content.trim() !== '') {\n                return content;\n            }\n\n            // 2nd choice - Cerebras\n            content = await callCerebrasModel('qwen-3-32b', userPrompt, env);\n            if (content && content.trim() !== '') {\n                return content;\n            }\n\n            // 3rd choice - Gemini\n            content = await callGeminiModel('gemini-2.5-flash-lite-preview-06-17', userPrompt, env);\n            if (content && content.trim() !== '') {\n                return content;\n            }\n\n            return SEND({\n                error: 'Failed to connect to any AI model.'\n            }, 467);\n        }\n    } catch (err) {\n        console.error('callAiModel error:', err);\n        return SEND({\n            error: 'Error in callAiModel: ' + err.message\n        }, 467);\n    }\n}\n\nexport default {\n    async fetch(request, env) {\n        const url = new URL(request.url);\n\n        if (request.method === 'OPTIONS') {\n            return SEND(null, 204);\n        }\n\n        switch (url.pathname) {\n            case '/signup':\n                {\n                    if (request.method !== 'POST') return SEND({\n                        error: 'Method not allowed'\n                    }, 405);\n\n                    try {\n                        const {\n                            email,\n                            password\n                        } = await request.json();\n\n                        if (!email || !password) {\n                            return SEND({\n                                error: 'Email and password are required.'\n                            }, 400);\n                        }\n                        if (password.length < 8) {\n                            return SEND({\n                                error: 'Password must be at least 8 characters long.'\n                            }, 400);\n                        }\n\n                        const existingUser = await env.DB.prepare('SELECT user_id, email, verified_email, data FROM users WHERE email = ?').bind(email).first();\n                        if (existingUser && existingUser.verified_email) {\n                            return SEND({\n                                error: 'User with this email already exists.'\n                            }, 409);\n                        }\n\n                        const salt = crypto.randomUUID().replaceAll('-', '');\n                        const password_hash = await hash(password, salt);\n                        const verification_code = Math.floor(100000 + Math.random() * 900000).toString();\n                        const verification_code_expires_at = Date.now() + (10 * 60 * 1000); // 10 minutes\n\n                        let user_id;\n\n                        if (existingUser) { // User exists but is not verified\n                            // Use the existing user_id\n                            user_id = existingUser.user_id;\n                            \n                            const userData = JSON.parse(existingUser.data || '{}');\n                            userData.verification_code = verification_code;\n                            userData.verification_code_expires_at = verification_code_expires_at;\n                            await env.DB.prepare(\n                                `UPDATE users SET password_hash = ?, salt = ?, data = ? WHERE email = ?`\n                            ).bind(password_hash, salt, JSON.stringify(userData), email).run();\n                        } else {\n                            user_id = crypto.randomUUID().replaceAll('-', '');\n                            user_id = user_id.slice(0, 8);\n                            const userData = {\n                                verification_code,\n                                verification_code_expires_at\n                            };\n                            await env.DB.prepare(\n                                `INSERT INTO users (user_id, email, verified_email, data, dataspec, usage, timestamp, plan, payment_times, login_attempts, provider, password_hash, salt)\n                                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n                            ).bind(\n                                user_id,\n                                email,\n                                false, // verified_email\n                                JSON.stringify(userData), // data\n                                1, // dataspec\n                                0, // usage\n                                Date.now(), // timestamp\n                                'free', // plan\n                                '[]', // payment_times\n                                '[]', // login_attempts\n                                'email', // provider\n                                password_hash,\n                                salt\n                            ).run();\n                        }\n\n                        const emailContent = `Your verification code is: ${verification_code}`;\n                        await sendEmail(env.SENDGRID_API_KEY, email, 'Verify your email for Scribblit', emailContent);\n\n                        return SEND({\n                            message: 'Verification code sent to your email.',\n                            id: user_id\n                        });\n\n                    } catch (err) {\n                        console.error('Signup error:', err);\n                        return SEND({\n                            error: 'Failed to process signup request.'\n                        }, 500);\n                    }\n                }\n\n            case '/verify-email':\n                {\n                    if (request.method !== 'POST') return SEND({\n                        error: 'Method not allowed'\n                    }, 405);\n                    try {\n                        const {\n                            email,\n                            code\n                        } = await request.json();\n                        if (!email || !code) {\n                            return SEND({\n                                error: 'Email and verification code are required.'\n                            }, 400);\n                        }\n\n                        const user = await env.DB.prepare('SELECT user_id, data, verified_email FROM users WHERE email = ?').bind(email).first();\n\n                        if (!user) {\n                            return SEND({\n                                error: 'User not found.'\n                            }, 404);\n                        }\n\n                        if (user.verified_email) {\n                            return SEND({\n                                error: 'Email is already verified.'\n                            }, 400);\n                        }\n\n                        const userData = JSON.parse(user.data);\n\n                        if (!userData.verification_code_expires_at || Date.now() > userData.verification_code_expires_at) {\n                            return SEND({\n                                error: 'Verification code has expired.'\n                            }, 400);\n                        }\n\n                        if (userData.verification_code !== code) {\n                            return SEND({\n                                error: 'Invalid verification code.'\n                            }, 400);\n                        }\n\n                        delete userData.verification_code;\n                        delete userData.verification_code_expires_at;\n\n                        await env.DB.prepare(\n                            'UPDATE users SET verified_email = ?, data = ? WHERE email = ?'\n                        ).bind(true, \"{}\", email).run();\n    \n                        const token = await generateToken(email, env.SECRET_KEY);\n                        return SEND({\n                            token,\n                            id: user.user_id\n                        });\n\n                    } catch (err) {\n                        console.error('Email verification error:', err);\n                        return SEND({\n                            error: 'Failed to process email verification.'\n                        }, 500);\n                    }\n                }\n\n            case '/login':\n                {\n                    if (request.method !== 'POST') return SEND({\n                        error: 'Method not allowed'\n                    }, 405);\n\n                    try {\n                        const {\n                            email,\n                            password\n                        } = await request.json();\n                        if (!email || !password) {\n                            return SEND({\n                                error: 'Email and password are required.'\n                            }, 400);\n                        }\n\n                        const user = await env.DB.prepare('SELECT user_id, password_hash, salt, verified_email FROM users WHERE email = ?').bind(email).first();\n                        if (!user) {\n                            return SEND({\n                                error: 'Invalid credentials.'\n                            }, 401);\n                        }\n\n                        if (!user.verified_email) {\n                            return SEND({\n                                error: 'Please verify your email before logging in.'\n                            }, 401);\n                        }\n\n                        const hashedPassword = await hash(password, user.salt);\n                        if (user.password_hash !== hashedPassword) {\n                            return SEND({\n                                error: 'Invalid credentials.'\n                            }, 401);\n                        }\n\n                        const token = await generateToken(email, env.SECRET_KEY);\n                        return SEND({\n                            token,\n                            id: user.user_id\n                        });\n\n                    } catch (err) {\n                        console.error('Login error:', err);\n                        return SEND({\n                            error: 'Failed to process login request.'\n                        }, 500);\n                    }\n                }\n\n            case '/get-user':\n                {\n                    if (request.method !== 'GET') return SEND({\n                        error: 'Method Not Allowed'\n                    }, 405);\n\n                    try {\n                        const authHeader = request.headers.get('Authorization');\n                        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n                            return SEND({\n                                error: 'Authorization header is missing or invalid.'\n                            }, 401);\n                        }\n\n                        const token = authHeader.substring(7); // Remove 'Bearer '\n                        const email = await verifyToken(token, env.SECRET_KEY);\n\n                        if (!email) {\n                            return SEND({\n                                error: 'Invalid or expired token.'\n                            }, 401);\n                        }\n\n                        const userResult = await env.DB.prepare(\n                            'SELECT user_id, email, data, dataspec, usage, timestamp, plan, payment_times FROM users WHERE email = ?'\n                        ).bind(email).first();\n\n                        if (!userResult) {\n                            return SEND({\n                                error: 'User not found.'\n                            }, 404);\n                        }\n\n                        const userJson = {\n                            _type: 'User',\n                            userId: userResult.user_id,\n                            email: userResult.email,\n                            data: userResult.data, // This is a stringified JSON\n                            dataspec: userResult.dataspec,\n                            usage: userResult.usage,\n                            timestamp: userResult.timestamp,\n                            plan: userResult.plan,\n                            paymentTimes: JSON.parse(userResult.payment_times),\n                        };\n\n                        const newToken = await generateToken(email, env.SECRET_KEY);\n\n                        return SEND({\n                            user: userJson,\n                            token: newToken\n                        });\n\n                    } catch (err) {\n                        console.error('Get user error:', err);\n                        return SEND({\n                            error: 'Failed to get user data.'\n                        }, 500);\n                    }\n                }\n\n            case '/update-user':\n                {\n                    if (request.method !== 'POST') return SEND({ error: 'Method Not Allowed' }, 405);\n\n                    try {\n                        const authHeader = request.headers.get('Authorization');\n                        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n                            return SEND({ error: 'Authorization header is missing or invalid.' }, 401);\n                        }\n                        const token = authHeader.substring(7);\n                        const email = await verifyToken(token, env.SECRET_KEY);\n                        if (!email) {\n                            return SEND({ error: 'Invalid or expired token.' }, 401);\n                        }\n\n                        const {\n                            data,\n                            dataspec,\n                            timestamp,\n                        } = await request.json();\n\n                        if (typeof data !== 'string' || typeof dataspec !== 'number' || typeof timestamp !== 'number') {\n                            return SEND({ error: 'Invalid user data.' }, 400);\n                        }\n\n                        await env.DB.prepare(\n                            `UPDATE users SET data = ?, dataspec = ?, timestamp = ? WHERE email = ?`\n                        ).bind(\n                            data,\n                            dataspec,\n                            timestamp,\n                            email\n                        ).run();\n\n                        return SEND({ success: true });\n                    } catch (err) {\n                        console.error('Update user error:', err);\n                        return SEND({ error: 'Failed to update user data.' }, 500);\n                    }\n                }\n\n            case '/send-email':\n                if (request.method !== 'POST') {\n                    return SEND({\n                        error: 'Method Not Allowed'\n                    }, 405);\n                }\n                try {\n                    const {\n                        to,\n                        subject,\n                        content\n                    } = await request.json();\n                    await sendEmail(env.SENDGRID_API_KEY, to, subject, content);\n                    return SEND('Email sent', 200);\n                } catch (err) {\n                    return SEND(err.message || err.toString(), 500);\n                }\n\n            case '/auth/google':\n                {\n                    if (request.method !== 'GET') {\n                        return SEND({ error: 'Method not allowed' }, 405);\n                    }\n                    \n                    const state = crypto.randomUUID();\n                    const googleAuthUrl = 'https://accounts.google.com/o/oauth2/v2/auth?' +\n                        `response_type=code&` +\n                        `client_id=${env.GOOGLE_CLIENT_ID}&` +\n                        `redirect_uri=${encodeURIComponent('https://' + SERVER_DOMAIN + '/auth/google/callback')}&` +\n                        `scope=${encodeURIComponent('openid email')}&` +\n                        `state=${state}`;\n                    \n                    return Response.redirect(googleAuthUrl, 302);\n                }\n\n            case '/auth/google/callback':\n                {\n                    if (request.method !== 'GET') {\n                        return SEND({ error: 'Method not allowed' }, 405);\n                    }\n                    \n                    try {\n                        const { searchParams } = new URL(request.url);\n                        const code = searchParams.get('code');\n                        const error = searchParams.get('error');\n                        \n                        if (error) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=oauth_error`, 302);\n                        }\n                        \n                        if (!code) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=no_code`, 302);\n                        }\n                        \n                        // Exchange code for access token\n                        const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/x-www-form-urlencoded',\n                            },\n                            body: new URLSearchParams({\n                                code,\n                                client_id: env.GOOGLE_CLIENT_ID,\n                                client_secret: env.GOOGLE_CLIENT_SECRET,\n                                redirect_uri: 'https://' + SERVER_DOMAIN + '/auth/google/callback',\n                                grant_type: 'authorization_code',\n                            }),\n                        });\n                        \n                        const tokenData = await tokenResponse.json();\n                        \n                        if (!tokenData.access_token) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=token_error`, 302);\n                        }\n                        \n                        // Get user info from Google\n                        const userResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n                            headers: {\n                                'Authorization': `Bearer ${tokenData.access_token}`,\n                            },\n                        });\n                        \n                        const googleUser = await userResponse.json();\n                        \n                        if (!googleUser.email) {\n                            return Response.redirect(`https://${PAGES_DOMAIN}/?error=no_email`, 302);\n                        }\n                        \n                        // Check if user exists\n                        let user = await env.DB.prepare('SELECT user_id, email, verified_email, data FROM users WHERE email = ?')\n                            .bind(googleUser.email).first();\n                        \n                        let user_id;\n                        \n                        if (user) {\n                            // Update existing user to use Google OAuth\n                            user_id = user.user_id;\n                            await env.DB.prepare(\n                                'UPDATE users SET provider = ?, provider_id = ?, verified_email = ? WHERE email = ?'\n                            ).bind('google', googleUser.id, true, googleUser.email).run();\n                        } else {\n                            // Create new user\n                            user_id = crypto.randomUUID().replaceAll('-', '').slice(0, 8);\n                            await env.DB.prepare(\n                                `INSERT INTO users (user_id, email, verified_email, data, dataspec, usage, timestamp, plan, payment_times, login_attempts, provider, provider_id)\n                                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n                            ).bind(\n                                user_id,\n                                googleUser.email,\n                                true, // verified_email\n                                '{}', // data\n                                1, // dataspec\n                                0, // usage\n                                Date.now(), // timestamp\n                                'free', // plan\n                                '[]', // payment_times\n                                '[]', // login_attempts\n                                'google', // provider\n                                googleUser.id // provider_id\n                            ).run();\n                        }\n                        \n                        // Generate JWT token\n                        const token = await generateToken(googleUser.email, env.SECRET_KEY);\n                        \n                        // Redirect to frontend with token\n                        return Response.redirect(`https://${PAGES_DOMAIN}/?token=${token}&id=${user_id}`, 302);\n                        \n                    } catch (err) {\n                        console.error('Google OAuth callback error:', err);\n                        return Response.redirect(`https://${PAGES_DOMAIN}/?error=callback_error`, 302);\n                    }\n                }\n\n            case '/test-email-integration':\n                if (request.method !== 'GET') {\n                    return SEND({\n                        error: 'Method Not Allowed'\n                    }, 405);\n                }\n                try {\n                    await sendEmail(\n                        env.SENDGRID_API_KEY,\n                        'liamtswayne@gmail.com',\n                        'Test Integration',\n                        'This is a test email from your Cloudflare Worker. If you see this, the SendGrid integration is working.'\n                    );\n                    return SEND('Test email sent', 200);\n                } catch (err) {\n                    return SEND(err.message || err.toString(), 500);\n                }\n\n            case '/ai/parse':\n                {\n                    if (request.method !== 'POST') return SEND({ error: 'Method Not Allowed' }, 405);\n                    try {\n                        const data = await request.json();\n                        const userText = data.prompt;\n                        const fileArray = data.fileArray;\n\n                        if (userText == null || userText.length === 0) {\n                            return SEND({ error: 'Empty request body' }, 400);\n                        }\n\n                        const aiOutput = await callAiModel(userText, fileArray, env);\n                        console.log(\"AI output: \" + aiOutput);\n                        return SEND(aiOutput, 200);\n                    } catch (err) {\n                        console.error('AI parse error:', err);\n                        return SEND({ error: 'Failed to process AI request: ' + err.message }, 563);\n                    }\n                }\n\n            default:\n                return SEND({\n                    error: 'Endpoint not found'\n                }, 404);\n        }\n    }\n};\n\nasync function sendEmail(apiKey, to, subject, content) {\n    const msg = {\n        personalizations: [{\n            to: [{\n                email: to\n            }]\n        }],\n        from: {\n            email: 'hello@scribbl.it'\n        },\n        subject: subject,\n        content: [{\n            type: 'text/plain',\n            value: content\n        }]\n    };\n\n    const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n        method: 'POST',\n        headers: {\n            Authorization: `Bearer ${apiKey}`,\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(msg)\n    });\n\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`SendGrid API error: ${errorText}`);\n    }\n}"],
  "mappings": "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",
  "names": []
}
