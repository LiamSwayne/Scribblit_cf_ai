<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scribblit</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- JSON parser that allows trailing commas produced by the LLM -->
    <script src="https://unpkg.com/json5@2/dist/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/2.3.1/luxon.min.js"></script>
    <style>
        :root {
            --grey-1: #e0e0e0;  /* Lightest - Used for text */
            --grey-2: #888888;  /* Used for task dates and times */
            --grey-3: #666666;  /* Used for hover states */
            --grey-4: #444444;  /* Used for borders and lines */
            --grey-5: #2d2d2d;  /* Used for input background */
            --grey-6: #1e1e1e;  /* Darkest - Used for body background */
        }

        body {
            display: flex;
            flex-direction: column;
            margin: 0;
            padding-top: 10px;
            padding-left: 10px;
            box-sizing: border-box;
            font-family: 'Lexend', sans-serif;
            background-color: var(--grey-6);
            color: var(--grey-1);
        }

        .container {
            display: flex;
            flex-grow: 1;
            height: calc(100vh - 10px);
            position: relative;
        }

        .left-column {
            width: calc(50% - 10px);
            padding-right: 10px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #centerLine {
            background-color: var(--grey-4);
            width: 2px;
            position: fixed;
            left: calc(50% + 4px);
            top: 8px;
            height: calc(100% - 16px);
        }

        #taskInput {
            width: calc(100% - 3px);
            min-height: 100px;
            margin-bottom: 30px;
            background-color: var(--grey-5);
            color: var(--grey-1);
            border: 1px solid var(--grey-4);
            padding: 10px;
            resize: none;
            position: relative;
            top: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-y: hidden;
            box-sizing: border-box;
            transition: min-height 0.3s ease, height 0.3s ease;
        }

        @keyframes cursorPulse {
            0% {
                caret-color: #61a3ff; /* Starting with blue */
            }
            50% {
                caret-color: #d477ff; /* Transitioning to purple */
            }
            100% {
                caret-color: #61a3ff; /* Back to blue */
            }
        }

        #taskInput:focus {
            outline: none;
            border-color: var(--grey-4);
            animation: cursorPulse 3s infinite ease-in-out;
        } 

        .task-section-container {
            width: 100%;
        }

        .task-section {
            width: 100%;
            transition: opacity 0.3s ease;
        }

        .section-border {
            height: 2px;
            background-color: var(--grey-4);
            margin: 5px 0;
        }

        .empty-section .task-section {
            opacity: 0.5;
        }

        .empty-section .section-title {
            color: var(--grey-2);
        }

        .section-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .task-list {
            padding: 0;
            width: 100%;
        }

        .task-list > div {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }

        .task-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }

        .task-asterisk {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: var(--grey-2);
            margin-right: 21px;
            min-width: 24px;
            text-align: right;
            margin-top: 0px;
        }

        .task-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--grey-2);
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
        }

        .task-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--grey-2);
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
            text-align: center;
        }

        .task-date-time {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 0px;
            margin-top: -5px;
        }

        .task-date-no-time {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 0px;
            margin-top: 0px;
        }

        .task-date-time .task-time {
            font-size: 9.5px;
            margin-top: -2px;
        }

        .navigation {
            position: absolute;
            left: calc(50% + 10px);
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #allDayEvents {
            position: absolute;
            top: 23px;
            left: calc(50% + 14px);
            right: 4px;
            padding-bottom: 4px;
            margin-top: 6px;
        }

        #calendar {
            position: absolute;
            top: 60px;
            left: calc(50% + 10px);
            right: 10px;
            bottom: 10px;
            overflow-y: auto;
            border-bottom: 1px solid var(--grey-4);
        }

        .calendar-event {
            position: absolute;
            left: 60px;
            padding-top: 2px;
            padding-left: 5px;
            padding-right: 5px;
            padding-bottom: 3px;
            margin: 3.5px;
            color: var(--grey-1);
            border-radius: 8px;
            font-size: 12px;
            box-sizing: border-box;
            transition: opacity 0.3s ease;
        }

        .navigation button {
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            position: relative;
            overflow: hidden;
        }

        .navigation button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid var(--grey-1);
            border-radius: 50%;
            transition: border-width 0.3s ease;
        }

        .navigation button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: linear-gradient(45deg, #61a3ff, #d477ff);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .navigation button:hover::before {
            border-width: 0;
        }

        .navigation button:hover::after {
            opacity: 1;
            animation: rotateGradient 3.5s linear infinite;
        }

        .navigation button svg {
            width: 14px;
            height: 14px;
            position: relative;
            z-index: 1;
            stroke: #ffffff;
            stroke-width: 3;
        }

        .hour-marker {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px solid var(--grey-4);
            pointer-events: none;
        }

        .hour-label {
            position: absolute;
            left: 0;
            width: 50px;
            text-align: right;
            padding-right: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--grey-2);
        }

        .animated-text-container {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: var(--grey-1);
            background-color: var(--grey-5);
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .animated-text {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #animationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
            padding: 1px;
        }

        .all-day-event {
            display: flex;
            align-items: flex-start;
            margin-bottom: 5px;
        }

        .all-day-event .task-asterisk {
            margin-right: 10px;
        }

        #currentDate {
            position: absolute;
            top: -7px;
            font-size: 16px;
            font-weight: bold;
            margin: 0 10px;
            opacity: 0;
        }

        #dayOfWeek {
            position: absolute;
            top: 14px;
            color: var(--grey-2);
            font-size: 13px;
            margin-top: -2px;
        }

        #prevDay {
            left: 10px;
        }

        .task-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            width: 100%;
        }

        .task-checkbox {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            margin-left: 8px;
            border: 2px solid var(--grey-4);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            top: -1px;
            right: -1px;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .task-checkbox:checked {
            background-color: var(--grey-4);
            border-color: var(--grey-4);
        }

        .task-checkbox:checked::after {
            content: '\2714';
            font-size: 12px;
            color: var(--grey-1);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .task-checkbox:hover {
            border-color: var(--grey-3);
        }

        .task-checkbox:checked:hover {
            background-color: var(--grey-3);
            border-color: var(--grey-3);
        }

        .task-content {
            flex: 1;
            transition: color 0.3s, text-decoration 0.3s;
        }

        .overdue-task {
            position: relative;
        }

        .overdue-task::before {
            content: '';
            position: absolute;
            top: 0;
            left: 42px;
            right: 0;
            bottom: 0;
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255, 0, 0, 0.08) 10px,
                rgba(255, 0, 0, 0.08) 20px
            );
            z-index: -1;
            transition: opacity 0.3s ease;
            border-radius: 4px;
        }

        .overdue-task-done::before {
            opacity: 0;
        }

        .overdue-task .task-date,
        .overdue-task .task-time {
            color: #ff4444;
            transition: color 0.3s ease;
        }

        .overdue-task-done .task-date,
        .overdue-task-done .task-time {
            color: var(--grey-3);
        }

        @keyframes slideUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        @keyframes fadeInGrow {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes rotateGradient {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .calendar-no-transition {
            transition: none !important;
        }
    </style>
</head>
<body>
    <div id="centerLine"></div>
    <img src="./scribblit_logo_2.svg" alt="Scribblit Logo" style="position: fixed; width: 100px; height: auto;">
    <div class="container">
        <div class="left-column">
            <div style="position: relative;">
                <textarea id="taskInput" spellcheck="false" placeholder="Scribble your tasks here..."></textarea>
                <div id="animationOverlay"></div>
            </div>
            <div id="taskSections">
                <!-- Task sections will be dynamically inserted here -->
            </div>
        </div>
            <div class="navigation">
                <button id="prevDay" aria-label="Previous day">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <span id="currentDate"></span>
                    <span id="dayOfWeek"></span>
                </div>
                <button id="nextDay" aria-label="Next day">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"/>
                    </svg>
                </button>
            </div>
            <div id="allDayEvents"></div>
            <div id="calendar"></div>
    </div>
    <script>
        let WORKERS_DOMAIN = 'scribblit-server.unrono.workers.dev';

        // Global array to store all tasks and events
        let taskEventArray = [];

        // how far the calendar is from the top of the page when there are no all-day events
        const calendarToTopDistanceNoAllDay = 32;

        const DateTime = luxon.DateTime;
        let currentDate = DateTime.now().minus({ days: 100000 });; // start here so that the first call to changeDate will set it to today
        const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        const taskInput = document.getElementById('taskInput');
        const originalHeight = '100px'; // Store the original height
        let isAnimating = false;
        let animationCooldown = false;
        let isFirstRender = true;

        const todayTaskList = document.getElementById('todayTaskList');
        const tomorrowTaskList = document.getElementById('tomorrowTaskList');
        const weekTaskList = document.getElementById('weekTaskList');
        const calendar = document.getElementById('calendar');
        const currentDateEl = document.getElementById('currentDate');
        const dayOfWeekEl = document.getElementById('dayOfWeek');
        const prevDayBtn = document.getElementById('prevDay');
        const nextDayBtn = document.getElementById('nextDay');

        taskInput.addEventListener('keydown', function(event) {
            // pressing enter and not shift+enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                processInput();
            }
        });

        prevDayBtn.addEventListener('click', () => changeDate(-1));
        nextDayBtn.addEventListener('click', () => changeDate(1));

        function changeDate(delta) {
            const allDayEventsContainer = document.getElementById('allDayEvents');
            const oldAllDayEventCount = allDayEventsContainer.querySelectorAll('.all-day-event').length;
            const oldEvents = Array.from(calendar.querySelectorAll('.calendar-event'));

            // Update date immediately
            currentDate = currentDate.plus({ days: delta });
            updateDateDisplay();

            // Function to handle the main animation logic
            const animateChanges = () => {
                // Clear all-day events container
                allDayEventsContainer.innerHTML = '';
                
                // Render new calendar without showing events
                renderCalendar(false);

                // Count new all-day events
                const newAllDayEventCount = allDayEventsContainer.querySelectorAll('.all-day-event').length;

                // Calculate new calendar position
                const newCalendarTop = newAllDayEventCount > 0 ? 
                    allDayEventsContainer.offsetHeight - 6 + calendarToTopDistanceNoAllDay : 
                    calendarToTopDistanceNoAllDay;

                // Animate calendar to new position
                calendar.style.transition = 'top 0.3s ease';
                calendar.style.top = `${newCalendarTop}px`;

                // Handle all-day events visibility
                if (newAllDayEventCount > 0) {
                    allDayEventsContainer.style.transition = 'opacity 0.3s ease';
                    allDayEventsContainer.style.opacity = '0';
                    setTimeout(() => {
                        allDayEventsContainer.style.opacity = '1';
                    }, 150);
                } else {
                    allDayEventsContainer.style.opacity = '0';
                }

                // Fade in new events
                const newEvents = Array.from(calendar.querySelectorAll('.calendar-event'));
                newEvents.forEach((event, index) => {
                    setTimeout(() => {
                        event.style.opacity = '1';
                    }, index * 50);
                });
            };

            // Check if the current day is empty
            if (oldEvents.length === 0 && oldAllDayEventCount === 0) {
                // If current day is empty, start animations immediately
                animateChanges();
            } else {
                // If there are events, fade them out first
                oldEvents.forEach(event => {
                    event.style.opacity = '0';
                    event.style.transition = 'opacity 0.3s ease';
                });

                // Fade out all-day events if they exist
                if (oldAllDayEventCount > 0) {
                    allDayEventsContainer.style.transition = 'opacity 0.3s ease';
                    allDayEventsContainer.style.opacity = '0';
                }

                // Wait for fade out to complete before starting new animations
                setTimeout(() => {
                    // Remove old events
                    oldEvents.forEach(event => event.remove());
                    animateChanges();
                }, 300);
            }
        }

        function adjustTextareaHeight() {
            if (!isAnimating && !animationCooldown) {
                taskInput.style.height = 'auto';
                taskInput.style.height = `${taskInput.scrollHeight}px`;
            }
        }

        taskInput.addEventListener('input', adjustTextareaHeight);

        function updateDateDisplay() {
            const today = DateTime.local();
            
            if (currentDate.hasSame(today, 'day')) {
                currentDateEl.textContent = 'Today';
            } else if (currentDate.hasSame(today.plus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Tomorrow';
            } else if (currentDate.hasSame(today.minus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Yesterday';
            } else {
                currentDateEl.textContent = currentDate.toFormat('M/d');
            }
            
            // Update day of week
            dayOfWeekEl.textContent = currentDate.toFormat('cccc');
        }

        async function processInput() {
            const input = taskInput.value;
            const animationOverlay = document.getElementById('animationOverlay');
            
            const currentHeight = taskInput.style.height;
            isAnimating = true;

            // Get current date and time in user's timezone
            const now = DateTime.now().setZone(userTimezone);
            const currentDate = now.toISODate();
            const currentTime = now.toFormat('HH:mm');
            const dayOfWeek = now.weekdayLong.toLowerCase(); // Get the day of the week
            
            const inputRect = taskInput.getBoundingClientRect();
            const overlayRect = animationOverlay.getBoundingClientRect();
            
            // Create a single container for all lines
            const animatedTextContainer = document.createElement('div');
            animatedTextContainer.className = 'animated-text-container';
            animatedTextContainer.style.position = 'absolute';
            animatedTextContainer.style.top = `${inputRect.top - overlayRect.top}px`;
            animatedTextContainer.style.left = `${inputRect.left - overlayRect.left}px`;
            animatedTextContainer.style.width = `${inputRect.width}px`;
            animatedTextContainer.style.height = `${inputRect.height}px`;
            
            // Split input into lines and create animated lines
            input.split('\n').forEach((line, index) => {
                const animatedLine = document.createElement('div');
                animatedLine.className = 'animated-text';
                animatedLine.textContent = line;
                animatedTextContainer.appendChild(animatedLine);
            });

            animationOverlay.appendChild(animatedTextContainer);

            // Clear input but maintain height
            taskInput.value = '';
            taskInput.style.height = currentHeight;

            // Start all animations at once with different delays
            Array.from(animatedTextContainer.children).forEach((line, index) => {
                setTimeout(() => {
                    line.style.opacity = '0';
                    line.style.transform = 'translateY(-10px)';
                }, index * 50);
            });

            // Wait for all animations to complete
            await new Promise(resolve => setTimeout(resolve, (input.split('\n').length - 1) * 50 + 300));

            // Clear animation overlay
            animationOverlay.innerHTML = '';

            // Animate text area back to original height
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            // Reset transition and set cooldown after animation
            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    adjustTextareaHeight();
                }, 500);
            }, 300);

            try {
                const response = await fetch(`https://${WORKERS_DOMAIN}/process-input`, {
                    method: 'POST',
                    body: `${currentDate},${currentTime},${dayOfWeek},${input}`
                });

                if (!response.ok) {
                    console.log('response (error):', response);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const responseText = await response.text();

                let parsedResponse;
                try {
                    parsedResponse = JSON5.parse(responseText);
                } catch (parseError) {
                    console.log('Error parsing response:', parseError);
                    throw new Error('Invalid response format');
                }

                console.log('Parsed response:', parsedResponse);

                updateTaskEventArray(parsedResponse);
                saveToLocalStorage();
                renderTasks();
                renderCalendar();
            } catch (error) {
                console.log('Error processing input:', error.message);
                console.log('Stack:', error.stack);
                alert('Sorry, there was an error processing your input. Please try again later.');
            }

            // Reset the input area and animation
            taskInput.value = '';
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    adjustTextareaHeight();
                }, 500);
            }, 300);
        }

        function updateTaskEventArray(newItems) {
            newItems.forEach(item => {
                const sanitizedItem = { 
                    ...item, 
                    date: convertToISODate(item.date), 
                    done: {}
                };
                taskEventArray.push(sanitizedItem);
            });
            saveToLocalStorage();
        }

        function updateSectionTitleStyle(section, taskCount, completedCount) {
            const sectionContainer = document.querySelector(`.task-section-container:has(#${section}TaskList)`);
            const titleElement = sectionContainer.querySelector('.section-title');
            
            if (taskCount === 0 || taskCount === completedCount) {
                titleElement.style.color = '#666'; // Darken the title
            } else {
                titleElement.style.color = ''; // Reset to default color
            }

            // Special handling for overdue section
            if (section === 'overdue') {
                if (taskCount === 0) {
                    sectionContainer.style.display = 'none';
                } else {
                    sectionContainer.style.display = 'block';
                }
            }
        }

        function convertToISODate(dateString) {
            const today = DateTime.local().setZone(userTimezone);

            if (dateString) {
                if (dateString === 'today') {
                    return today.toISODate();
                } else if (dateString === 'tomorrow') {
                    return today.plus({ days: 1 }).toISODate();
                } else if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    return dateString; // Already in ISO format
                } else if (dateString.match(/^[a-z]+(\+\d+)?$/)) {
                    // Extract the day name and optional offset
                    const match = dateString.match(/^([a-z]+)(?:\+(\d+))?$/);
                    if (!match) return today.toISODate(); // Fallback to today if match fails
                    
                    const [_, day, offsetStr] = match;
                    const offset = offsetStr ? parseInt(offsetStr) : 0;
                    
                    // Get the weekday index (1-7, where 1 is Monday)
                    const weekdayIndex = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                        .indexOf(day.toLowerCase()) + 1;
                    
                    if (weekdayIndex === 0) return today.toISODate(); // Invalid day name
                    
                    // Find the next occurrence of this weekday
                    let targetDate = today.set({ weekday: weekdayIndex });
                    
                    // If the target date is before today, move to next week
                    if (targetDate < today) {
                        targetDate = targetDate.plus({ weeks: 1 });
                    }
                    
                    // Add any additional weeks specified by the offset
                    if (offset > 0) {
                        targetDate = targetDate.plus({ weeks: offset });
                    }
                    
                    return targetDate.toISODate();
                }
            }
            
            // The date is null or invalid format, return today as fallback
            console.log(`Invalid or null date found: ${dateString}`);
            return today.toISODate();
        }

        function renderTasks() {
            const taskSections = document.getElementById('taskSections');
            taskSections.innerHTML = '';

            const now = DateTime.now().setZone(userTimezone);
            const today = now.startOf('day');
            const tomorrow = today.plus({ days: 1 });
            const weekEnd = today.plus({ days: 7 });

            // Create sections
            const sections = ['today', 'tomorrow', 'week'];
            sections.forEach((section, index) => {
                const sectionContainer = document.createElement('div');
                sectionContainer.className = 'task-section-container';
                
                const sectionElement = document.createElement('div');
                sectionElement.className = 'task-section';
                
                const titleElement = document.createElement('div');
                titleElement.className = 'section-title';
                titleElement.textContent = section.charAt(0).toUpperCase() + section.slice(1);
                
                const taskList = document.createElement('div');
                taskList.id = `${section}TaskList`;
                taskList.className = 'task-list';
                
                sectionElement.appendChild(titleElement);
                sectionElement.appendChild(taskList);
                sectionContainer.appendChild(sectionElement);
                
                if (index < sections.length - 1) {
                    const border = document.createElement('div');
                    border.className = 'section-border';
                    sectionContainer.appendChild(border);
                }
                
                taskSections.appendChild(sectionContainer);
            });

            let todayTaskCount = 0;
            let todayCompletedCount = 0;
            let tomorrowTaskCount = 0;
            let tomorrowCompletedCount = 0;
            let weekTaskCount = 0;
            let weekCompletedCount = 0;

            // Filter and sort tasks
            const tasks = taskEventArray.filter(item => item.kind === "task");
            
            // Generate all dates for recurring tasks within the week range
            const expandedTasks = [];
            tasks.forEach(task => {
                if (task.recurPattern) {
                    const dates = generateRecurringDates(task, today.toISODate(), weekEnd.toISODate());
                    dates.forEach(date => {
                        expandedTasks.push({
                            ...task,
                            date: date,
                            originalDate: task.date,
                            isRecurring: true
                        });
                    });
                } else {
                    expandedTasks.push({ ...task, isRecurring: false });
                }
            });

            // Sort expanded tasks
            expandedTasks.sort((a, b) => {
                const aDate = DateTime.fromISO(a.date);
                const bDate = DateTime.fromISO(b.date);
                if (aDate.equals(bDate)) {
                    const aTime = a.endTime ? timeToMinutes(a.endTime) : 1440;
                    const bTime = b.endTime ? timeToMinutes(b.endTime) : 1440;
                    return aTime - bTime;
                }
                return aDate.valueOf() - bDate.valueOf();
            });

            expandedTasks.forEach(task => {
                const taskDate = DateTime.fromISO(task.date);
                
                // Create the task list item
                const listItem = document.createElement('div');
                listItem.className = 'task-item';
                
                // Create task content
                const taskContent = document.createElement('span');
                taskContent.className = 'task-content';
                taskContent.textContent = task.name;
                if (task.isRecurring) {
                    taskContent.textContent += ' (recurring)';
                }

                // Create checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'task-checkbox';
                
                // Check completion status
                const completionData = task.done[task.date];
                const isCompleted = completionData?.completed || false;
                const completedAt = completionData?.completedAt ? DateTime.fromISO(completionData.completedAt) : null;
                const completedToday = completedAt?.hasSame(today, 'day') || false;

                checkbox.checked = isCompleted;
                
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        task.done[task.date] = {
                            completed: true,
                            completedAt: now.toISO()
                        };
                    } else {
                        delete task.done[task.date];
                    }
                    
                    saveToLocalStorage();
                    
                    const taskItem = checkbox.closest('.task-item');
                    if (taskItem.classList.contains('overdue-task')) {
                        if (checkbox.checked) {
                            taskItem.classList.add('overdue-task-done');
                        } else {
                            taskItem.classList.remove('overdue-task-done');
                        }
                    }
                    
                    renderTasks();
                });

                if (isCompleted) {
                    taskContent.style.textDecoration = 'line-through';
                    taskContent.style.color = '#666';
                }

                let taskDateTime = task.endTime ? 
                    taskDate.set({
                        hour: parseInt(task.endTime.split(':')[0]),
                        minute: parseInt(task.endTime.split(':')[1])
                    }) : 
                    taskDate.endOf('day');

                const isOverdue = taskDateTime < now;
                const isDueToday = taskDate.hasSame(today, 'day');
                
                // Determine if the task should be shown in today's section
                const showInToday = isDueToday || // Due today
                                (isOverdue && !isCompleted) || // Overdue and not completed
                                (isOverdue && isCompleted && completedToday); // Overdue and completed today

                if (showInToday) {
                    // Today's tasks (including relevant overdue tasks)
                    const dateTimeSpan = document.createElement('span');
                    
                    if (isOverdue && !isDueToday) {
                        // Show full date for overdue tasks not due today
                        dateTimeSpan.className = task.endTime ? 'task-date-time' : 'task-date-no-time';
                        const dateSpan = document.createElement('span');
                        dateSpan.className = 'task-date';
                        dateSpan.textContent = taskDate.toFormat('MM/dd');
                        dateTimeSpan.appendChild(dateSpan);
                        
                        if (task.endTime) {
                            const timeSpan = document.createElement('span');
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = task.endTime;
                            dateTimeSpan.appendChild(timeSpan);
                        }
                    } else {
                        // Show just time or asterisk for today's tasks
                        if (task.endTime) {
                            dateTimeSpan.className = 'task-time';
                            dateTimeSpan.textContent = task.endTime;
                        } else {
                            dateTimeSpan.className = 'task-asterisk';
                            dateTimeSpan.textContent = '*';
                        }
                    }

                    if (isOverdue) {
                        listItem.classList.add('overdue-task');
                        if (isCompleted) {
                            listItem.classList.add('overdue-task-done');
                        }
                        dateTimeSpan.style.color = isCompleted ? '#666' : '#ff4444';
                    } else if (isCompleted) {
                        dateTimeSpan.style.color = '#666';
                    }

                    listItem.appendChild(dateTimeSpan);
                    listItem.appendChild(taskContent);
                    listItem.appendChild(checkbox);
                    document.getElementById('todayTaskList').appendChild(listItem);
                    todayTaskCount++;
                    if (isCompleted) todayCompletedCount++;

                } else if (taskDate.hasSame(tomorrow, 'day')) {
                    // Tomorrow's tasks
                    const timeSpan = document.createElement('span');
                    if (task.endTime) {
                        timeSpan.className = 'task-time';
                        timeSpan.textContent = task.endTime;
                    } else {
                        timeSpan.className = 'task-asterisk';
                        timeSpan.textContent = '*';
                    }

                    if (isCompleted) {
                        timeSpan.style.color = '#666';
                    }

                    listItem.appendChild(timeSpan);
                    listItem.appendChild(taskContent);
                    listItem.appendChild(checkbox);
                    document.getElementById('tomorrowTaskList').appendChild(listItem);
                    tomorrowTaskCount++;
                    if (isCompleted) tomorrowCompletedCount++;

                } else if (taskDate > tomorrow && taskDate <= weekEnd) {
                    // Week's tasks
                    const dateTimeSpan = document.createElement('span');
                    if (task.endTime) {
                        dateTimeSpan.className = 'task-date-time';
                    } else {
                        dateTimeSpan.className = 'task-date-no-time';
                    }
                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'task-date';
                    dateSpan.textContent = taskDate.toFormat('MM/dd');
                    dateTimeSpan.appendChild(dateSpan);
                    
                    if (task.endTime) {
                        const timeSpan = document.createElement('span');
                        timeSpan.className = 'task-time';
                        timeSpan.textContent = task.endTime;
                        dateTimeSpan.appendChild(timeSpan);
                    }

                    if (isCompleted) {
                        dateSpan.style.color = '#666';
                        if (task.endTime) {
                            dateTimeSpan.querySelector('.task-time').style.color = '#666';
                        }
                    }

                    listItem.appendChild(dateTimeSpan);
                    listItem.appendChild(taskContent);
                    listItem.appendChild(checkbox);
                    document.getElementById('weekTaskList').appendChild(listItem);
                    weekTaskCount++;
                    if (isCompleted) weekCompletedCount++;
                }
            });

            // Update section title styling
            updateSectionTitleStyle('today', todayTaskCount, todayCompletedCount);
            updateSectionTitleStyle('tomorrow', tomorrowTaskCount, tomorrowCompletedCount);
            updateSectionTitleStyle('week', weekTaskCount, weekCompletedCount);
        }

        function renderCalendar(showEvents = true) {
            console.log("called renderCalendar");
            calendar.innerHTML = '';
            const allDayEventsContainer = document.getElementById('allDayEvents');
            allDayEventsContainer.innerHTML = '';
            
            // Remove transition for first render
            if (isFirstRender) {
                calendar.classList.add('calendar-no-transition');
            }

            // Render time markers
            for (let i = 0; i < 24; i++) {
                const hourMarker = document.createElement('div');
                hourMarker.className = 'hour-marker';
                hourMarker.style.top = `${i / 24 * 100}%`;

                const hourLabel = document.createElement('div');
                hourLabel.className = 'hour-label';
                hourLabel.textContent = `${i.toString().padStart(2, '0')}:00`;
                hourLabel.style.top = `${i / 24 * 100}%`;

                calendar.appendChild(hourMarker);
                calendar.appendChild(hourLabel);
            }
            
            let shouldUpdateLocalStorage = false;
            // this only operaties on events, but we want to edit task array so changes will be saved
            taskEventArray.forEach(event => {
                if (event.kind == "event") {
                    if (event.startTime) {
                        if (!isValidTime(event.startTime)) {
                            shouldUpdateLocalStorage = true;
                            const calculatedDate = calculateActualDate(event.startTime);
                            if (calculatedDate) {
                                event.date = calculatedDate;
                                delete event.startTime;
                            } else {
                                // delete the time because no info can be inferred
                                delete event.startTime;
                            }
                        }
                    }
                }
            });

            // Process events
            let events = taskEventArray.filter(item => item.kind === "event" && DateTime.fromISO(item.date).hasSame(currentDate, 'day'));

            if (shouldUpdateLocalStorage) {
                saveToLocalStorage();
            }

            console.log('events:', events);

            // Separate all-day events and events without calculable start times
            let allDayEvents = events.filter(event => !event.startTime || !isValidTime(event.startTime));
            let timedEvents = events.filter(event => event.startTime && isValidTime(event.startTime));

            // Handle all-day events
            if (allDayEvents.length > 0) {
                allDayEventsContainer.innerHTML = '<div class="section-title">All-day</div>';
                allDayEvents.forEach(event => {
                    const eventEl = document.createElement('div');
                    eventEl.className = 'all-day-event';
                    const asterisk = document.createElement('span');
                    asterisk.className = 'task-asterisk';
                    asterisk.textContent = '*';
                    const eventContent = document.createElement('span');
                    eventContent.textContent = event.name;
                    eventEl.appendChild(asterisk);
                    eventEl.appendChild(eventContent);
                    allDayEventsContainer.appendChild(eventEl);
                });
            }

            // Calculate new calendar position immediately
            const newCalendarTop = allDayEvents.length > 0 ? 
                allDayEventsContainer.offsetHeight - 6 + calendarToTopDistanceNoAllDay : 
                calendarToTopDistanceNoAllDay;

            // Set position without transition on first render
            if (isFirstRender) {
                calendar.style.top = `${newCalendarTop}px`;
                allDayEventsContainer.style.opacity = allDayEvents.length > 0 ? '1' : '0';
            } else {
                calendar.style.transition = 'top 0.3s ease';
                calendar.style.top = `${newCalendarTop}px`;
                
                if (allDayEvents.length > 0) {
                    allDayEventsContainer.style.transition = 'opacity 0.3s ease';
                    allDayEventsContainer.style.opacity = '0';
                    setTimeout(() => {
                        allDayEventsContainer.style.opacity = '1';
                    }, 150);
                } else {
                    allDayEventsContainer.style.opacity = '0';
                }
            }

            // Sort the timed events by start time
            timedEvents.sort((a, b) => {
                const aTime = timeToMinutes(a.startTime || '00:00');
                const bTime = timeToMinutes(b.startTime || '00:00');
                return aTime - bTime;
            });

            const colors = ['#3a506b', '#5b7553', '#6b4f4f', '#4f4f6b', '#6b5b4f'];
            const lanes = [];
            const calendarWidth = calendar.offsetWidth;
            const generalCalOffset = 54;
            const laneWidth = 8;
            const spaceBetweenEvents = 4;

            // Group events by start time
            const eventGroups = [];
            let currentGroup = [];
            let currentStartTime = null;

            timedEvents.forEach((event, index) => {
                const startTime = event.startTime || '00:00';
                if (startTime !== currentStartTime) {
                    if (currentGroup.length > 0) {
                        eventGroups.push(currentGroup);
                    }
                    currentGroup = [event];
                    currentStartTime = startTime;
                } else {
                    currentGroup.push(event);
                }
                
                if (index === timedEvents.length - 1 && currentGroup.length > 0) {
                    eventGroups.push(currentGroup);
                }
            });

            // Render timed events
            eventGroups.forEach(group => {
                const groupStartMinutes = timeToMinutes(group[0].startTime || '00:00');
                const groupEndMinutes = Math.max(...group.map(e => {
                    if (e.endTime) {
                        return timeToMinutes(e.endTime);
                    } else {
                        return Math.min(groupStartMinutes + 100, 1440); // Default to 100 minutes if no end time
                    }
                }));

                // Find the first available lane for the group
                let laneIndex = 0;
                while (true) {
                    if (!lanes[laneIndex]) {
                        lanes[laneIndex] = [];
                    }
                    const lane = lanes[laneIndex];
                    
                    let conflict = false;
                    for (let i = 0; i < lane.length; i++) {
                        const event = lane[i];
                        const eventStart = event.start || 0; // Default to 0 if null
                        const eventEnd = event.end || Math.min(eventStart + 100, 1440); // Default to 100 minutes if null

                        if (groupStartMinutes < eventEnd && groupEndMinutes > eventStart) {
                            conflict = true;
                            break;
                        }
                    }

                    if (!conflict) {
                        lane.push({ start: groupStartMinutes, end: groupEndMinutes });
                        break;
                    }
                    laneIndex++;
                }

                const availableWidth = calendarWidth - (laneIndex * laneWidth) - generalCalOffset - 7;
                const eventWidth = (availableWidth - (spaceBetweenEvents * (group.length - 1))) / group.length;

                group.forEach((item, index) => {
                    const itemStartMinutes = timeToMinutes(item.startTime || '00:00');
                    const itemEndMinutes = item.endTime ? timeToMinutes(item.endTime) : Math.min(itemStartMinutes + 100, 1440);

                    const eventEl = document.createElement('div');
                    eventEl.className = 'calendar-event';
                    eventEl.textContent = item.name;
                    eventEl.style.left = `${laneIndex * laneWidth + generalCalOffset + (index * (eventWidth + spaceBetweenEvents))}px`;
                    eventEl.style.width = `${eventWidth}px`;
                    eventEl.style.top = `${itemStartMinutes / 1440 * 100}%`;
                    
                    const color = colors[laneIndex % colors.length];
                    
                    if (item.endTime) {
                        eventEl.style.height = `calc(${(itemEndMinutes - itemStartMinutes) / 1440 * 100}% - 7px)`;
                        eventEl.style.backgroundColor = color;
                    } else {
                        eventEl.style.height = `calc(${(100) / 1440 * 100}% - 7px)`; // 100 minutes
                        eventEl.style.background = `linear-gradient(
                            to bottom,
                            ${color} 0%,
                            ${color} 20%,
                            ${color} 20%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.6) 60%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.4) 70%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.2) 85%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.1) 90%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0) 100%
                        )`;
                        eventEl.style.borderBottomLeftRadius = '0';
                        eventEl.style.borderBottomRightRadius = '0';
                    }

                    // Set z-index based on the event's position in the sorted array
                    eventEl.style.zIndex = timedEvents.indexOf(item) + 1;

                    if (!showEvents) {
                        eventEl.style.opacity = '0';
                    }

                    calendar.appendChild(eventEl);
                });
            });

            // After the first render, remove the no-transition class and set the flag
            if (isFirstRender) {
                // Use requestAnimationFrame to ensure the no-transition class is removed after the initial render
                requestAnimationFrame(() => {
                    calendar.classList.remove('calendar-no-transition');
                    isFirstRender = false;
                });
            }
        }

        function timeToMinutes(time) {
            const [hours, minutes] = time.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function saveToLocalStorage() {
            localStorage.setItem('taskEventArray', JSON.stringify(taskEventArray));
        }

        // take a date string from startTime, which shouldn't have a day but sometimes AI hallucinates and gives it a day, so we try to infer the correct date before clearing the field
        function calculateActualDate(dateString) {
            const today = DateTime.local().setZone(userTimezone);
            
            if (dateString === 'today') {
                return today.toISODate();
            } else if (dateString === 'tomorrow') {
                return today.plus({ days: 1 }).toISODate();
            } else {
                const daysOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                const dayIndex = daysOfWeek.indexOf(dateString.toLowerCase());
                if (dayIndex !== -1) {
                    let targetDate = today.set({ weekday: dayIndex + 1 });
                    if (targetDate < today) {
                        targetDate = targetDate.plus({ weeks: 1 });
                    }
                    return targetDate.toISODate();
                }
            }
            
            return null;
        }

        function isValidTime(timeString) {
            return /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeString);
        }

        function updateButtonStyles() {
            const buttons = document.querySelectorAll('.navigation button');
            buttons.forEach(button => {
                button.addEventListener('mouseenter', () => {
                    button.style.color = '#ffffff';
                });
                button.addEventListener('mouseleave', () => {
                    button.style.color = '';
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Load from local storage
            const storedData = localStorage.getItem('taskEventArray');
            if (storedData) {
                taskEventArray = JSON.parse(storedData);
            }

            document.getElementById('allDayEvents').style.opacity = '0';
            updateDateDisplay();
            renderCalendar(false);

            // wait for the animations to finish
            setTimeout(() => {
                changeDate(100000);
                // fade in current date
                document.getElementById('currentDate').style.transition = 'opacity 0.3s ease';
                document.getElementById('currentDate').style.opacity = '1';
            }, 350);

            // Keep these lines if they're not already present in your initialization
            updateButtonStyles();
            adjustTextareaHeight();

                // Perform other initializations
                updateButtonStyles();
                adjustTextareaHeight();
                renderTasks();

            // Set up resize event listener
            window.addEventListener('resize', () => {
                renderCalendar();
            });
        });

        // helper function to generate recurring dates from the string returned by the AI
        function generateRecurringDates(task, startDate, endDate) {
            const start = DateTime.fromISO(startDate);
            const end = DateTime.fromISO(endDate);
            const dates = [];
            
            if (!task.recurPattern) return [task.date];

            let current = DateTime.fromISO(task.date);
            
            // Handle specific weekday patterns like "monday,tuesday" or "monday@15:00,tuesday@16:00"
            if (task.recurPattern.includes(',')) {
                const patterns = task.recurPattern.split(',');
                while (current <= end) {
                    patterns.forEach(pattern => {
                        let [day, time] = pattern.split('@');
                        const weekdayIndex = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                            .indexOf(day.toLowerCase());
                        
                        if (weekdayIndex !== -1) {
                            let nextOccurrence = current.set({ weekday: weekdayIndex + 1 });
                            if (nextOccurrence < current) {
                                nextOccurrence = nextOccurrence.plus({ weeks: 1 });
                            }
                            
                            // If this specific weekday has a time override
                            if (time) {
                                const [hours, minutes] = time.split(':').map(Number);
                                task.endTime = time;
                            }
                            
                            if (nextOccurrence >= start && nextOccurrence <= end) {
                                dates.push(nextOccurrence.toISODate());
                            }
                        }
                    });
                    current = current.plus({ weeks: 1 });
                }
                return [...new Set(dates)]; // Remove duplicates
            }

            // Handle monthly patterns
            if (task.recurPattern.startsWith('monthly_')) {
                const pattern = task.recurPattern.substring(8); // Remove 'monthly_' prefix
                while (current <= end) {
                    let nextDate = current;
                    
                    if (pattern === 'first_day') {
                        nextDate = current.startOf('month');
                    } else if (pattern.includes('_')) {
                        const [ord, day] = pattern.split('_'); // e.g., 'first', 'monday'
                        const weekdayIndex = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                            .indexOf(day.toLowerCase());
                        
                        if (weekdayIndex !== -1) {
                            const ordinalMap = {
                                'first': 1, 'second': 2, 'third': 3, 'fourth': 4, 'last': -1
                            };
                            
                            const ordinal = ordinalMap[ord];
                            if (ordinal) {
                                if (ordinal === -1) {
                                    nextDate = current.endOf('month').set({ weekday: weekdayIndex + 1 });
                                    while (nextDate.month !== current.month) {
                                        nextDate = nextDate.minus({ weeks: 1 });
                                    }
                                } else {
                                    nextDate = current.startOf('month').set({ weekday: weekdayIndex + 1 });
                                    nextDate = nextDate.plus({ weeks: ordinal - 1 });
                                    while (nextDate.month !== current.month) {
                                        nextDate = nextDate.minus({ weeks: 1 });
                                    }
                                }
                            }
                        }
                    }
                    
                    if (nextDate >= start && nextDate <= end) {
                        dates.push(nextDate.toISODate());
                    }
                    
                    current = current.plus({ months: 1 });
                }
                return dates;
            }

            // Handle other recurrence patterns
            const intervalMap = {
                'daily': { days: 1 },
                'weekly': { weeks: 1 },
                'biweekly': { weeks: 2 },
                'monthly': { months: 1 },
                'yearly': { years: 1 }
            };

            // Handle "weekly+n" pattern
            if (task.recurPattern.startsWith('weekly+')) {
                const weeks = parseInt(task.recurPattern.split('+')[1]);
                intervalMap.custom = { weeks };
            }

            const interval = intervalMap[task.recurPattern] || intervalMap.custom;
            if (!interval) return [task.date];

            while (current <= end) {
                if (current >= start) {
                    dates.push(current.toISODate());
                }
                current = current.plus(interval);
            }

            return dates;
        }

        // !testing
        /*
        localStorage.removeItem('taskEventArray');
        document.getElementById('taskInput').textContent =
        `meeting with math teacher on tuseday
meeting with advisor today
math HW due 6 pm today!!!
networking at the gates hillman super hill center from 3 to 9
bio lab on friday
finish recording new song by tomorrow
calc pre-test due by thursday
programming homework before 3pm friday
remind me to buy carrots from target
study session starting at 5:00
studying from 1 pm to 3:25
studying from 7 to 8
meet up with omar for 20 minutes from 7:30
cycling practice from 7 to 8
remind Bill to pick up cold medicine`
*/
    </script>
</body>
</html>