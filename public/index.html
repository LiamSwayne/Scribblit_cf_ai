<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scribblit</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" 
    rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- JSON parser that allows trailing commas produced by the LLM -->
    <script src="https://unpkg.com/json5@2/dist/index.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            flex-grow: 1;
        }
        .title {
            margin-bottom: 4px;
        }
        .title img {
            max-width: 100px;
            height: auto;
        }
        .section-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .left-column {
            flex: 1;
            padding-right: 20px;
            display: flex;
            flex-direction: column;
        }
        .right-column {
            flex: 1;
            border-left: 1px solid #444;
            padding-left: 20px;
            position: relative;
            overflow: hidden;
        }
        #taskInput {
            width: 100%;
            min-height: 100px;
            margin-bottom: 10px;
            background-color: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 10px;
            resize: none;
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-y: hidden;
            box-sizing: border-box;
            transition: min-height 0.3s ease, height 0.3s ease;
        }
        #taskInput:focus {
            outline: none;
            border-color: #444;
        }
        .task-section {
            margin-bottom: 10px;
        }
        .task-list {
            padding: 0;
        }
        .task-list > div {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        .task-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        .task-asterisk {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #888;
            margin-right: 21px;
            min-width: 24px;
            text-align: right;
            margin-top: 0px;
        }
        .task-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
        }
        .task-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
            text-align: center;
        }
        .task-date-time {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 0px;
            margin-top: -6px;
        }
        .task-date-no-time {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 0px;
            margin-top: 0px;
        }
        .task-date-time .task-time {
            font-size: 9.5px;
            margin-top: -2px;
        }
        .task-content {
            flex: 1;
        }
        #calendar {
            position: absolute;
            top: 40px;
            left: 20px;
            right: 0;
            overflow-y: auto;
            height: 1160px;
        }
        .calendar-event {
            position: absolute;
            left: 60px;
            right: 0;
            padding-top: 2px;
            padding-left: 5px;
            padding-right: 5px;
            padding-bottom: 3px;
            margin: 3.5px;
            color: #e0e0e0;
            border-radius: 8px;
            font-size: 12px;
            box-sizing: border-box;
            transition: opacity 0.3s ease;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .navigation button {
            background-color: #3a506b;
            color: #e0e0e0;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
        }
        .hour-marker {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px solid #444;
            pointer-events: none;
        }
        .hour-label {
            position: absolute;
            left: 0;
            width: 50px;
            text-align: right;
            padding-right: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        @keyframes slideUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        .animated-text-container {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #e0e0e0;
            background-color: #2d2d2d;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .animated-text {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #animationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
            padding: 1px;
        }
    </style>
</head>
<body>
    <div class="title">
        <img src="./scribblit_logo_2.svg" alt="Scribblit Logo" style="width: 200px; height: auto;">
    </div>
    <div class="container">
        <div class="left-column">
            <div style="position: relative;">
                <textarea id="taskInput" spellcheck="false" placeholder="Scribble your tasks here..."></textarea>
                <div id="animationOverlay"></div>
            </div>
            <div class="task-section">
                <div class="section-title">Today</div>
                <div id="todayTaskList" class="task-list"></div>
            </div>
            <div class="task-section">
                <div class="section-title">Tomorrow</div>
                <div id="tomorrowTaskList" class="task-list"></div>
            </div>
            <div class="task-section">
                <div class="section-title">This Week</div>
                <div id="weekTaskList" class="task-list"></div>
            </div>
        </div>
        <div class="right-column">
            <div class="navigation">
                <button id="prevDay">&lt;</button>
                <span id="currentDate">Today</span>
                <button id="nextDay">&gt;</button>
            </div>
            <div id="calendar"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/2.3.1/luxon.min.js"></script>
    <script>
        // Global array to store all tasks and events
        let taskEventArray = [];

        const DateTime = luxon.DateTime;
        let currentDate = DateTime.local();
        // rotate during testing
        // AIzaSyDgiM5ZhWqxsI_hoNAaJeSChCh5SkztGoc
        // AIzaSyDxLOhwro6jpIHUBssb_hcavahQwOGrjPQ
        const apiKey = 'AIzaSyDxLOhwro6jpIHUBssb_hcavahQwOGrjPQ';

        const taskInput = document.getElementById('taskInput');
        const originalHeight = '100px'; // Store the original height
        let isAnimating = false;
        let animationCooldown = false;

        const todayTaskList = document.getElementById('todayTaskList');
        const tomorrowTaskList = document.getElementById('tomorrowTaskList');
        const weekTaskList = document.getElementById('weekTaskList');
        const calendar = document.getElementById('calendar');
        const currentDateEl = document.getElementById('currentDate');
        const prevDayBtn = document.getElementById('prevDay');
        const nextDayBtn = document.getElementById('nextDay');

        taskInput.addEventListener('keydown', function(event) {
            // pressing enter and not shift+enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                processInput();
            }
        });

        prevDayBtn.addEventListener('click', () => changeDate(-1));
        nextDayBtn.addEventListener('click', () => changeDate(1));

        function changeDate(delta) {
            const oldEvents = Array.from(calendar.querySelectorAll('.calendar-event'));
            
            // Fade out old events
            oldEvents.forEach(event => {
                event.style.animation = 'fadeOut 0.3s forwards';
            });

            setTimeout(() => {
                // Remove old events
                oldEvents.forEach(event => event.remove());
                
                // Update date and render new calendar
                currentDate = currentDate.plus({ days: delta });
                updateDateDisplay();
                renderCalendar();
                
                // Fade in new events
                Array.from(calendar.querySelectorAll('.calendar-event')).forEach(event => {
                    event.style.opacity = '0';
                    event.style.animation = 'fadeIn 0.3s forwards';
                });
            }, 300);
        }

        function adjustTextareaHeight() {
            if (!isAnimating && !animationCooldown) {
                taskInput.style.height = 'auto';
                taskInput.style.height = `${taskInput.scrollHeight}px`;
            }
        }

        taskInput.addEventListener('input', adjustTextareaHeight);

        function updateDateDisplay() {
            const today = DateTime.local();
            if (currentDate.hasSame(today, 'day')) {
                currentDateEl.textContent = 'Today';
            } else if (currentDate.hasSame(today.plus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Tomorrow';
            } else if (currentDate.hasSame(today.minus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Yesterday';
            } else {
                currentDateEl.textContent = currentDate.toFormat('M/d');
            }
        }

        async function processInput() {
            const input = taskInput.value;
            const animationOverlay = document.getElementById('animationOverlay');
            
            const currentHeight = taskInput.style.height;
            isAnimating = true;
            
            const inputRect = taskInput.getBoundingClientRect();
            const overlayRect = animationOverlay.getBoundingClientRect();
            
            // Create a single container for all lines
            const animatedTextContainer = document.createElement('div');
            animatedTextContainer.className = 'animated-text-container';
            animatedTextContainer.style.position = 'absolute';
            animatedTextContainer.style.top = `${inputRect.top - overlayRect.top}px`;
            animatedTextContainer.style.left = `${inputRect.left - overlayRect.left}px`;
            animatedTextContainer.style.width = `${inputRect.width}px`;
            animatedTextContainer.style.height = `${inputRect.height}px`;
            
            // Split input into lines and create animated lines
            input.split('\n').forEach((line, index) => {
                const animatedLine = document.createElement('div');
                animatedLine.className = 'animated-text';
                animatedLine.textContent = line;
                animatedTextContainer.appendChild(animatedLine);
            });

            animationOverlay.appendChild(animatedTextContainer);

            // Clear input but maintain height
            taskInput.value = '';
            taskInput.style.height = currentHeight;

            // Start all animations at once with different delays
            Array.from(animatedTextContainer.children).forEach((line, index) => {
                setTimeout(() => {
                    line.style.opacity = '0';
                    line.style.transform = 'translateY(-10px)';
                }, index * 50);
            });

            // Wait for all animations to complete
            await new Promise(resolve => setTimeout(resolve, (input.split('\n').length - 1) * 50 + 300));

            // Clear animation overlay
            animationOverlay.innerHTML = '';

            // Animate text area back to original height
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            // Reset transition and set cooldown after animation
            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    adjustTextareaHeight();
                }, 500);
            }, 300);

            try {
                const response = await fetch('/process-input', {
                    method: 'POST',
                    body: input
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const parsedTasks = await response.json();
                updateTaskEventArray(parsedTasks);
                saveToLocalStorage();
                renderAllData();
            } catch (error) {
                console.error('Error processing input:', error);
                alert('Sorry, there was an error processing your input. Please try again later.');
            }

            // Reset the input area and animation
            taskInput.value = '';
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    adjustTextareaHeight();
                }, 500);
            }, 300);
        }

        function updateTaskEventArray(newItems) {
            newItems.forEach(item => {
                const sanitizedItem = { ...item, date: convertToISODate(item.date) };
                if (item.kind == 'event' && !item.startTime && !item.endTime) {
                    sanitizedItem.startTime = '00:00';
                }
                taskEventArray.push(sanitizedItem);
            });
            saveToLocalStorage();
        }

        function convertToISODate(dateString) {
            const today = DateTime.local();

            if (dateString) {
                if (dateString === 'today') {
                    return today.toISODate();
                } else if (dateString === 'tomorrow') {
                    return today.plus({ days: 1 }).toISODate();
                } else if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    return dateString; // Already in ISO format
                } else if (dateString.match(/^[a-z]+(\+\d+)?$/)) {
                    const [day, offset] = dateString.split('+');
                    let targetDate = today.set({ weekday: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].indexOf(day.toLowerCase()) + 1 });
                    
                    if (offset) {
                        targetDate = targetDate.plus({ weeks: parseInt(offset) });
                    }
                    
                    if (targetDate < today) {
                        targetDate = targetDate.plus({ weeks: 1 });
                    }
                    
                    return targetDate.toISODate();
                }
            }

            // If we can't parse the date, return today as a fallback
            console.error(`Unable to parse date: ${dateString}`);
            return today.toISODate();
        }

        function renderAllData() {
            todayTaskList.innerHTML = '';
            tomorrowTaskList.innerHTML = '';
            weekTaskList.innerHTML = '';
            renderCalendar();

            const today = DateTime.local();
            const tomorrow = today.plus({ days: 1 });
            const weekEnd = today.plus({ days: 7 });

            taskEventArray.forEach(item => {
                if (item.kind === "task") {
                    const listItem = document.createElement('div');
                    const taskContent = document.createElement('span');
                    taskContent.className = 'task-content';
                    taskContent.textContent = item.name;

                    let date = DateTime.fromISO(item.date)
                    if (date.hasSame(today, 'day') || date.hasSame(tomorrow, 'day')) {
                        const timeSpan = document.createElement('span');
                        if (item.endTime) {
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = item.endTime;
                        } else {
                            timeSpan.className = 'task-asterisk';
                            timeSpan.textContent = '*';
                        }

                        listItem.appendChild(timeSpan);
                        listItem.appendChild(taskContent);
                        
                        if (date.hasSame(today, 'day')) {
                            todayTaskList.appendChild(listItem);
                        } else {
                            tomorrowTaskList.appendChild(listItem);
                        }
                    } else if (date > tomorrow && date <= weekEnd) {
                        const dateTimeSpan = document.createElement('span');
                        if (item.endTime) {
                            dateTimeSpan.className = 'task-date-time';
                        } else {
                            dateTimeSpan.className = 'task-date-no-time';
                        }
                        const dateSpan = document.createElement('span');
                        dateSpan.className = 'task-date';
                        dateSpan.textContent = date.toFormat('MM/dd');
                        dateTimeSpan.appendChild(dateSpan);
                        
                        if (item.endTime) {
                            const timeSpan = document.createElement('span');
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = item.endTime;
                            dateTimeSpan.appendChild(timeSpan);
                        }
                        
                        listItem.appendChild(dateTimeSpan);
                        listItem.appendChild(taskContent);
                        weekTaskList.appendChild(listItem);
                    }
                }
            });
        }

        function renderCalendar() {
            calendar.innerHTML = '';
            
            // Render time markers
            for (let i = 0; i < 24; i++) {
                const hourMarker = document.createElement('div');
                hourMarker.className = 'hour-marker';
                hourMarker.style.top = `${i / 24 * 100}%`;

                const hourLabel = document.createElement('div');
                hourLabel.className = 'hour-label';
                hourLabel.textContent = `${i.toString().padStart(2, '0')}:00`;
                hourLabel.style.top = `${i / 24 * 100}%`;

                calendar.appendChild(hourMarker);
                calendar.appendChild(hourLabel);
            }

            // create an array of only events taking place on the current date
            let events = taskEventArray.filter(item => item.kind === "event" && DateTime.fromISO(item.date).hasSame(currentDate, 'day'));
            // sort the array by start time
            events.sort((a, b) => {
                const aTime = timeToMinutes(a.startTime || '00:00');
                const bTime = timeToMinutes(b.startTime || '00:00');
                return aTime - bTime;
            });

            console.log("Events: ", events);

            const colors = ['#3a506b', '#5b7553', '#6b4f4f', '#4f4f6b', '#6b5b4f'];
            const lanes = [];

            // Render events
            const calendarDate = currentDate.startOf('day');
            events.forEach((item, index) => {
                const startMinutes = timeToMinutes(item.startTime || '00:00');
                const endMinutes = item.endTime ? timeToMinutes(item.endTime) : Math.min(startMinutes + 100, 1440);

                // Find the first available lane
                let laneIndex = 0;
                while (true) {
                    if (!lanes[laneIndex]) {
                        lanes[laneIndex] = [];
                    }
                    const lane = lanes[laneIndex];
                    const conflict = lane.some(event => {
                        return (startMinutes < event.end && endMinutes > event.start);
                    });
                    if (!conflict) {
                        lane.push({ start: startMinutes, end: endMinutes });
                        break;
                    }
                    laneIndex++;
                }

                const eventEl = document.createElement('div');
                eventEl.className = 'calendar-event';
                eventEl.textContent = item.name;
                // reduce the width of the event based on how many events it overlaps with, subtracting from the left side
                const generalCalOffset = 54;
                const laneWidth = 10;
                eventEl.style.left = `${laneIndex * laneWidth + generalCalOffset}px`;
                
                eventEl.style.top = `${startMinutes / 1440 * 100}%`;
                
                // the color is the level indentation, basically the number of events it overlaps with
                const color = colors[laneIndex % colors.length];
                
                if (item.endTime) {
                    eventEl.style.height = `calc(${(endMinutes - startMinutes) / 1440 * 100}% - 7px)`;
                    eventEl.style.backgroundColor = color;
                } else {
                    eventEl.style.height = `calc(${(100) / 1440 * 100}% - 7px)`; // 100 minutes
                    eventEl.style.background = `linear-gradient(
                        to bottom,
                        ${color} 0%,
                        ${color} 20%,
                        ${color} 20%,
                        rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.6) 60%,
                        rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.4) 70%,
                        rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.2) 85%,
                        rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.1) 90%,
                        rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0) 100%
                    )`;
                    eventEl.style.borderBottomLeftRadius = '0';
                    eventEl.style.borderBottomRightRadius = '0';
                }

                // Set z-index based on the event's position in the sorted array
                eventEl.style.zIndex = index + 1;

                calendar.appendChild(eventEl);
            });
        }

        function timeToMinutes(time) {
            const [hours, minutes] = time.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function saveToLocalStorage() {
            localStorage.setItem('taskEventArray', JSON.stringify(taskEventArray));
        }

        // load from local storage
        const storedData = localStorage.getItem('taskEventArray');
        if (storedData) {
            taskEventArray = JSON.parse(storedData);
        }

        updateDateDisplay();
        renderAllData();
        adjustTextareaHeight();
    </script>
</body>
</html>