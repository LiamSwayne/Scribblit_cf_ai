<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scribblit</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- JSON parser that allows trailing commas produced by the LLM -->
    <script src="https://unpkg.com/json5@2/dist/index.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            flex-grow: 1;
            height: calc(100vh - 54px);
        }
        .title {
            margin-bottom: 4px;
        }
        .title img {
            max-width: 100px;
            height: auto;
        }
        .section-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 6px;
        }
        .left-column {
            flex: 1;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
        }
        .right-column {
            flex: 1;
            border-left: 2px solid #444;
            padding-left: 0px;
            position: relative;
            height: calc(100% + 30px);
            margin-top: -30px;
        }
        #taskInput {
            width: 100%;
            min-height: 100px;
            margin-bottom: 10px;
            background-color: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 10px;
            resize: none;
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-y: hidden;
            box-sizing: border-box;
            transition: min-height 0.3s ease, height 0.3s ease;
        }
        #taskInput:focus {
            outline: none;
            border-color: #444;
        }
        .task-section {
            margin-bottom: 5px;
        }
        .task-section:not(:last-child) {
            margin-bottom: 5px;
            border-bottom: 2px solid #444;
        }
        .task-list {
            padding: 0;
        }
        .task-list > div {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        .task-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        .task-asterisk {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #888;
            margin-right: 21px;
            min-width: 24px;
            text-align: right;
            margin-top: 0px;
        }
        .task-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
        }
        .task-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
            text-align: center;
        }
        .task-date-time {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 0px;
            margin-top: -6px;
        }
        .task-date-no-time {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 0px;
            margin-top: 0px;
        }
        .task-date-time .task-time {
            font-size: 9.5px;
            margin-top: -2px;
        }
        .task-content {
            flex: 1;
        }
        .empty-section {
            opacity: 0.5;
        }
        #calendar {
            position: absolute;
            margin-top: 2px;
            left: 10px;
            right: 0;
            overflow-y: auto;
            height: 1100px;
        }
        .calendar-event {
            position: absolute;
            left: 60px;
            padding-top: 2px;
            padding-left: 5px;
            padding-right: 5px;
            padding-bottom: 3px;
            margin: 3.5px;
            color: #e0e0e0;
            border-radius: 8px;
            font-size: 12px;
            box-sizing: border-box;
            transition: opacity 0.3s ease;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }
        .navigation button {
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            position: relative;
            overflow: hidden;
        }
        .navigation button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            transition: border-width 0.3s ease;
        }
        .navigation button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: linear-gradient(45deg, #61a3ff, #d477ff);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .navigation button:hover::before {
            border-width: 0;
        }
        .navigation button:hover::after {
            opacity: 1;
            animation: rotateGradient 3.5s linear infinite;
        }
        .navigation button svg {
            width: 14px;
            height: 14px;
            position: relative;
            z-index: 1;
            stroke: #ffffff;
            stroke-width: 3;
        }
        .hour-marker {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px solid #444;
            pointer-events: none;
        }
        .hour-label {
            position: absolute;
            left: 0;
            width: 50px;
            text-align: right;
            padding-right: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        @keyframes slideUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        .animated-text-container {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #e0e0e0;
            background-color: #2d2d2d;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .animated-text {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #animationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
            padding: 1px;
        }
        @keyframes fadeInGrow {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        .all-day-events {
            padding-bottom: 4px;
        }
        .all-day-event {
            display: flex;
            align-items: flex-start;
            margin-bottom: 5px;
        }
        .all-day-event .task-asterisk {
            margin-right: 10px;
        }
        #currentDate {
            font-size: 18px;
            font-weight: bold;
            margin: 0 10px;
        }
        @keyframes rotateGradient {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        #prevDay {
            left: 10px;
        }
        #nextDay {
        }
    </style>
</head>
<body>
    <div class="title">
        <img src="./scribblit_logo_2.svg" alt="Scribblit Logo" style="width: 200px; height: auto;">
    </div>
    <div class="container">
        <div class="left-column">
            <div style="position: relative;">
                <textarea id="taskInput" spellcheck="false" placeholder="Scribble your tasks here..."></textarea>
                <div id="animationOverlay"></div>
            </div>
            <div class="task-section">
                <div class="section-title">Today</div>
                <div id="todayTaskList" class="task-list"></div>
            </div>
            <div class="task-section">
                <div class="section-title">Tomorrow</div>
                <div id="tomorrowTaskList" class="task-list"></div>
            </div>
            <div class="task-section">
                <div class="section-title">This Week</div>
                <div id="weekTaskList" class="task-list"></div>
            </div>
        </div>
        <div class="right-column">
            <div class="navigation">
                <button id="prevDay" aria-label="Previous day">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span id="currentDate">Today</span>
                <button id="nextDay" aria-label="Next day">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"/>
                    </svg>
                </button>
            </div>
            <div id="allDayEvents" class="all-day-events"></div>
            <div id="calendar"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/2.3.1/luxon.min.js"></script>
    <script>
        let WORKERS_DOMAIN = 'scribblit-server.unrono.workers.dev';

        // Global array to store all tasks and events
        let taskEventArray = [];

        const DateTime = luxon.DateTime;
        let currentDate = DateTime.local();
        // rotate during testing
        // AIzaSyDgiM5ZhWqxsI_hoNAaJeSChCh5SkztGoc
        // AIzaSyDxLOhwro6jpIHUBssb_hcavahQwOGrjPQ
        const apiKey = 'AIzaSyDxLOhwro6jpIHUBssb_hcavahQwOGrjPQ';

        const taskInput = document.getElementById('taskInput');
        const originalHeight = '100px'; // Store the original height
        let isAnimating = false;
        let animationCooldown = false;

        const todayTaskList = document.getElementById('todayTaskList');
        const tomorrowTaskList = document.getElementById('tomorrowTaskList');
        const weekTaskList = document.getElementById('weekTaskList');
        const calendar = document.getElementById('calendar');
        const currentDateEl = document.getElementById('currentDate');
        const prevDayBtn = document.getElementById('prevDay');
        const nextDayBtn = document.getElementById('nextDay');

        taskInput.addEventListener('keydown', function(event) {
            // pressing enter and not shift+enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                processInput();
            }
        });

        prevDayBtn.addEventListener('click', () => changeDate(-1));
        nextDayBtn.addEventListener('click', () => changeDate(1));

        function changeDate(delta) {
            const oldEvents = Array.from(calendar.querySelectorAll('.calendar-event'));
            
            // Fade out old events
            oldEvents.forEach(event => {
                event.style.animation = 'fadeOut 0.3s forwards';
            });

            setTimeout(() => {
                // Remove old events
                oldEvents.forEach(event => event.remove());
                
                // Update date and render new calendar
                currentDate = currentDate.plus({ days: delta });
                updateDateDisplay();
                renderCalendar();
                
                // Fade in new events
                Array.from(calendar.querySelectorAll('.calendar-event')).forEach(event => {
                    event.style.opacity = '0';
                    event.style.animation = 'fadeIn 0.3s forwards';
                });
            }, 300);
        }

        function adjustTextareaHeight() {
            if (!isAnimating && !animationCooldown) {
                taskInput.style.height = 'auto';
                taskInput.style.height = `${taskInput.scrollHeight}px`;
            }
        }

        taskInput.addEventListener('input', adjustTextareaHeight);

        function updateDateDisplay() {
            const today = DateTime.local();
            if (currentDate.hasSame(today, 'day')) {
                currentDateEl.textContent = 'Today';
            } else if (currentDate.hasSame(today.plus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Tomorrow';
            } else if (currentDate.hasSame(today.minus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Yesterday';
            } else {
                currentDateEl.textContent = currentDate.toFormat('M/d');
            }
        }

        async function processInput() {
            const input = taskInput.value;
            const animationOverlay = document.getElementById('animationOverlay');
            
            const currentHeight = taskInput.style.height;
            isAnimating = true;
            
            const inputRect = taskInput.getBoundingClientRect();
            const overlayRect = animationOverlay.getBoundingClientRect();
            
            // Create a single container for all lines
            const animatedTextContainer = document.createElement('div');
            animatedTextContainer.className = 'animated-text-container';
            animatedTextContainer.style.position = 'absolute';
            animatedTextContainer.style.top = `${inputRect.top - overlayRect.top}px`;
            animatedTextContainer.style.left = `${inputRect.left - overlayRect.left}px`;
            animatedTextContainer.style.width = `${inputRect.width}px`;
            animatedTextContainer.style.height = `${inputRect.height}px`;
            
            // Split input into lines and create animated lines
            input.split('\n').forEach((line, index) => {
                const animatedLine = document.createElement('div');
                animatedLine.className = 'animated-text';
                animatedLine.textContent = line;
                animatedTextContainer.appendChild(animatedLine);
            });

            animationOverlay.appendChild(animatedTextContainer);

            // Clear input but maintain height
            taskInput.value = '';
            taskInput.style.height = currentHeight;

            // Start all animations at once with different delays
            Array.from(animatedTextContainer.children).forEach((line, index) => {
                setTimeout(() => {
                    line.style.opacity = '0';
                    line.style.transform = 'translateY(-10px)';
                }, index * 50);
            });

            // Wait for all animations to complete
            await new Promise(resolve => setTimeout(resolve, (input.split('\n').length - 1) * 50 + 300));

            // Clear animation overlay
            animationOverlay.innerHTML = '';

            // Animate text area back to original height
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            // Reset transition and set cooldown after animation
            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    adjustTextareaHeight();
                }, 500);
            }, 300);

            try {
                const response = await fetch(`https://${WORKERS_DOMAIN}/process-input`, {
                    method: 'POST',
                    body: input
                });

                if (!response.ok) {
                    console.log('response (error):', response);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const parsedTasks = await response.json();
                updateTaskEventArray(parsedTasks);
                saveToLocalStorage();
                renderAllData();
            } catch (error) {
                console.log('Error processing input:', error.message);
                console.log('Stack:', error.stack);
                alert('Sorry, there was an error processing your input. Please try again later.');
            }

            // Reset the input area and animation
            taskInput.value = '';
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    adjustTextareaHeight();
                }, 500);
            }, 300);
        }

        function updateTaskEventArray(newItems) {
            newItems.forEach(item => {
                const sanitizedItem = { ...item, date: convertToISODate(item.date) };
                if (item.kind == 'event' && !item.startTime && !item.endTime) {
                    sanitizedItem.startTime = '00:00';
                }
                taskEventArray.push(sanitizedItem);
            });
            saveToLocalStorage();
        }

        function convertToISODate(dateString) {
            const today = DateTime.local();

            if (dateString) {
                if (dateString === 'today') {
                    return today.toISODate();
                } else if (dateString === 'tomorrow') {
                    return today.plus({ days: 1 }).toISODate();
                } else if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    return dateString; // Already in ISO format
                } else if (dateString.match(/^[a-z]+(\+\d+)?$/)) {
                    const [day, offset] = dateString.split('+');
                    let targetDate = today.set({ weekday: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].indexOf(day.toLowerCase()) + 1 });
                    
                    if (offset) {
                        targetDate = targetDate.plus({ weeks: parseInt(offset) });
                    }
                    
                    if (targetDate < today) {
                        targetDate = targetDate.plus({ weeks: 1 });
                    }
                    
                    return targetDate.toISODate();
                }
            }

            // If we can't parse the date, return today as a fallback
            console.error(`Unable to parse date: ${dateString}`);
            return today.toISODate();
        }

        function renderAllData() {
            todayTaskList.innerHTML = '';
            tomorrowTaskList.innerHTML = '';
            weekTaskList.innerHTML = '';
            renderCalendar();

            const today = DateTime.local();
            const tomorrow = today.plus({ days: 1 });
            const weekEnd = today.plus({ days: 7 });

            let todayTaskCount = 0;
            let tomorrowTaskCount = 0;
            let weekTaskCount = 0;

            taskEventArray.forEach(item => {
                if (item.kind === "task") {
                    const listItem = document.createElement('div');
                    const taskContent = document.createElement('span');
                    taskContent.className = 'task-content';
                    taskContent.textContent = item.name;

                    let date = DateTime.fromISO(item.date)
                    if (date.hasSame(today, 'day') || date.hasSame(tomorrow, 'day')) {
                        const timeSpan = document.createElement('span');
                        if (item.endTime) {
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = item.endTime;
                        } else {
                            timeSpan.className = 'task-asterisk';
                            timeSpan.textContent = '*';
                        }

                        listItem.appendChild(timeSpan);
                        listItem.appendChild(taskContent);
                        
                        if (date.hasSame(today, 'day')) {
                            todayTaskList.appendChild(listItem);
                            todayTaskCount++;
                        } else {
                            tomorrowTaskList.appendChild(listItem);
                            tomorrowTaskCount++;
                        }
                    } else if (date > tomorrow && date <= weekEnd) {
                        const dateTimeSpan = document.createElement('span');
                        if (item.endTime) {
                            dateTimeSpan.className = 'task-date-time';
                        } else {
                            dateTimeSpan.className = 'task-date-no-time';
                        }
                        const dateSpan = document.createElement('span');
                        dateSpan.className = 'task-date';
                        dateSpan.textContent = date.toFormat('MM/dd');
                        dateTimeSpan.appendChild(dateSpan);
                        
                        if (item.endTime) {
                            const timeSpan = document.createElement('span');
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = item.endTime;
                            dateTimeSpan.appendChild(timeSpan);
                        }
                        
                        listItem.appendChild(dateTimeSpan);
                        listItem.appendChild(taskContent);
                        weekTaskList.appendChild(listItem);
                        weekTaskCount++;
                    }
                }
            });

            // Apply empty-section class if there are no tasks
            todayTaskList.closest('.task-section').classList.toggle('empty-section', todayTaskCount === 0);
            tomorrowTaskList.closest('.task-section').classList.toggle('empty-section', tomorrowTaskCount === 0);
            weekTaskList.closest('.task-section').classList.toggle('empty-section', weekTaskCount === 0);
        }

        function renderCalendar() {
            calendar.innerHTML = '';
            const allDayEventsContainer = document.getElementById('allDayEvents');
            allDayEventsContainer.innerHTML = '';
            
            // Render time markers
            for (let i = 0; i < 24; i++) {
                const hourMarker = document.createElement('div');
                hourMarker.className = 'hour-marker';
                hourMarker.style.top = `${i / 24 * 100}%`;

                const hourLabel = document.createElement('div');
                hourLabel.className = 'hour-label';
                hourLabel.textContent = `${i.toString().padStart(2, '0')}:00`;
                hourLabel.style.top = `${i / 24 * 100}%`;

                calendar.appendChild(hourMarker);
                calendar.appendChild(hourLabel);
            }
            
            let shouldUpdateLocalStorage = false;
            // this only operaties on events, but we want to edit task array so changes will be saved
            taskEventArray.forEach(event => {
                if (event.kind == "event") {
                    if (event.startTime) {
                        if (!isValidTime(event.startTime)) {
                            shouldUpdateLocalStorage = true;
                            const calculatedDate = calculateActualDate(event.startTime);
                            if (calculatedDate) {
                                event.date = calculatedDate;
                                delete event.startTime;
                            } else {
                                // delete the time because no info can be inferred
                                delete event.startTime;
                            }
                        }
                    }
                }
            });

            // Process events
            let events = taskEventArray.filter(item => item.kind === "event" && DateTime.fromISO(item.date).hasSame(currentDate, 'day'));

            if (shouldUpdateLocalStorage) {
                saveToLocalStorage();
            }

            console.log('events:', events);

            // Separate all-day events and events without calculable start times
            let allDayEvents = events.filter(event => !event.startTime || !isValidTime(event.startTime));
            let timedEvents = events.filter(event => event.startTime && isValidTime(event.startTime));

            // Render all-day events only if there are any
            if (allDayEvents.length > 0) {
                allDayEventsContainer.innerHTML = '<div class="section-title">All-day</div>';
                allDayEvents.forEach(event => {
                    const eventEl = document.createElement('div');
                    eventEl.className = 'all-day-event';
                    const asterisk = document.createElement('span');
                    asterisk.className = 'task-asterisk';
                    asterisk.textContent = '*';
                    const eventContent = document.createElement('span');
                    eventContent.textContent = event.name;
                    eventEl.appendChild(asterisk);
                    eventEl.appendChild(eventContent);
                    allDayEventsContainer.appendChild(eventEl);
                });
            }

            // Sort the timed events by start time
            timedEvents.sort((a, b) => {
                const aTime = timeToMinutes(a.startTime || '00:00');
                const bTime = timeToMinutes(b.startTime || '00:00');
                return aTime - bTime;
            });

            const colors = ['#3a506b', '#5b7553', '#6b4f4f', '#4f4f6b', '#6b5b4f'];
            const lanes = [];
            const calendarWidth = calendar.offsetWidth;
            const generalCalOffset = 54;
            const laneWidth = 8;
            const spaceBetweenEvents = 4;

            // Group events by start time
            const eventGroups = [];
            let currentGroup = [];
            let currentStartTime = null;

            timedEvents.forEach((event, index) => {
                const startTime = event.startTime || '00:00';
                if (startTime !== currentStartTime) {
                    if (currentGroup.length > 0) {
                        eventGroups.push(currentGroup);
                    }
                    currentGroup = [event];
                    currentStartTime = startTime;
                } else {
                    currentGroup.push(event);
                }
                
                if (index === timedEvents.length - 1 && currentGroup.length > 0) {
                    eventGroups.push(currentGroup);
                }
            });

            // Render timed events
            eventGroups.forEach(group => {
                const groupStartMinutes = timeToMinutes(group[0].startTime || '00:00');
                const groupEndMinutes = Math.max(...group.map(e => {
                    if (e.endTime) {
                        return timeToMinutes(e.endTime);
                    } else {
                        return Math.min(groupStartMinutes + 100, 1440); // Default to 100 minutes if no end time
                    }
                }));

                // Find the first available lane for the group
                let laneIndex = 0;
                while (true) {
                    if (!lanes[laneIndex]) {
                        lanes[laneIndex] = [];
                    }
                    const lane = lanes[laneIndex];
                    
                    let conflict = false;
                    for (let i = 0; i < lane.length; i++) {
                        const event = lane[i];
                        const eventStart = event.start || 0; // Default to 0 if null
                        const eventEnd = event.end || Math.min(eventStart + 100, 1440); // Default to 100 minutes if null

                        if (groupStartMinutes < eventEnd && groupEndMinutes > eventStart) {
                            conflict = true;
                            break;
                        }
                    }

                    if (!conflict) {
                        lane.push({ start: groupStartMinutes, end: groupEndMinutes });
                        break;
                    }
                    laneIndex++;
                }

                const availableWidth = calendarWidth - (laneIndex * laneWidth) - generalCalOffset - 7;
                const eventWidth = (availableWidth - (spaceBetweenEvents * (group.length - 1))) / group.length;

                group.forEach((item, index) => {
                    const itemStartMinutes = timeToMinutes(item.startTime || '00:00');
                    const itemEndMinutes = item.endTime ? timeToMinutes(item.endTime) : Math.min(itemStartMinutes + 100, 1440);

                    const eventEl = document.createElement('div');
                    eventEl.className = 'calendar-event';
                    eventEl.textContent = item.name;
                    eventEl.style.left = `${laneIndex * laneWidth + generalCalOffset + (index * (eventWidth + spaceBetweenEvents))}px`;
                    eventEl.style.width = `${eventWidth}px`;
                    eventEl.style.top = `${itemStartMinutes / 1440 * 100}%`;
                    
                    const color = colors[laneIndex % colors.length];
                    
                    if (item.endTime) {
                        eventEl.style.height = `calc(${(itemEndMinutes - itemStartMinutes) / 1440 * 100}% - 7px)`;
                        eventEl.style.backgroundColor = color;
                    } else {
                        eventEl.style.height = `calc(${(100) / 1440 * 100}% - 7px)`; // 100 minutes
                        eventEl.style.background = `linear-gradient(
                            to bottom,
                            ${color} 0%,
                            ${color} 20%,
                            ${color} 20%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.6) 60%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.4) 70%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.2) 85%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0.1) 90%,
                            rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, 0) 100%
                        )`;
                        eventEl.style.borderBottomLeftRadius = '0';
                        eventEl.style.borderBottomRightRadius = '0';
                    }

                    // Set z-index based on the event's position in the sorted array
                    eventEl.style.zIndex = timedEvents.indexOf(item) + 1;

                    calendar.appendChild(eventEl);
                });
            });
        }

        function timeToMinutes(time) {
            const [hours, minutes] = time.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function saveToLocalStorage() {
            localStorage.setItem('taskEventArray', JSON.stringify(taskEventArray));
        }

        // take a date string from startTime, which shouldn't have a day but sometimes AI hallucinates and gives it a day, so we try to infer the correct date before clearing the field
        function calculateActualDate(dateString) {
            const today = DateTime.local();
            
            if (dateString === 'today') {
                return today.toISODate();
            } else if (dateString === 'tomorrow') {
                return today.plus({ days: 1 }).toISODate();
            } else {
                const daysOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                const dayIndex = daysOfWeek.indexOf(dateString.toLowerCase());
                if (dayIndex !== -1) {
                    let targetDate = today.set({ weekday: dayIndex + 1 });
                    if (targetDate < today) {
                        targetDate = targetDate.plus({ weeks: 1 });
                    }
                    return targetDate.toISODate();
                }
            }
            
            return null;
        }

        function isValidTime(timeString) {
            return /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeString);
        }

        // load from local storage
        const storedData = localStorage.getItem('taskEventArray');
        if (storedData) {
            taskEventArray = JSON.parse(storedData);
        }

        function updateButtonStyles() {
            const buttons = document.querySelectorAll('.navigation button');
            buttons.forEach(button => {
                button.addEventListener('mouseenter', () => {
                    button.style.color = '#ffffff';
                });
                button.addEventListener('mouseleave', () => {
                    button.style.color = '';
                });
            });
        }


        updateDateDisplay();
        renderAllData();
        adjustTextareaHeight();
        updateButtonStyles();

        // Modified resize event listener
        window.addEventListener('resize', () => {
            renderCalendar();
        });
    </script>
</body>
</html>