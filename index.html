<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scribblit</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" 
    rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- JSON parser that allows trailing commas produced by the LLM -->
    <script src="https://unpkg.com/json5@2/dist/index.min.js"></script>
    <style>
                body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            flex-grow: 1;
        }
        .title {
            font-size: 30px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .section-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .left-column {
            flex: 1;
            padding-right: 20px;
            display: flex;
            flex-direction: column;
        }
        .right-column {
            flex: 1;
            border-left: 1px solid #444;
            padding-left: 20px;
            position: relative;
            overflow: hidden;
        }
        #taskInput {
            width: 100%;
            min-height: 100px;
            margin-bottom: 20px;
            background-color: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 10px;
            resize: none;
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-y: hidden;
            box-sizing: border-box;
            transition: min-height 0.3s ease, height 0.3s ease;
        }
        #taskInput:focus {
            outline: none;
            border-color: #444;
        }
        #animationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
        }
        .animated-text {
            position: absolute;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #e0e0e0;
            padding: 10px;
            background-color: #2d2d2d;
            opacity: 0;
            animation: floatAway 1s forwards;
            box-sizing: border-box;
            border: 1px solid transparent;
        }
        @keyframes floatAway {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }
        .task-section {
            margin-bottom: 20px;
        }
        .task-list {
            padding: 0;
        }
        .task-list > div {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        .task-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        .task-asterisk {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #888;
            margin-right: 7px;
            min-width: 20px;
            text-align: right;
            margin-top: 0px;
        }
        .task-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
        }
        .task-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
            margin-right: 7px;
            min-width: 38px;
            text-align: right;
            margin-top: 2px;
            text-align: center;
        }
        .task-date-time {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 7px;
        }
        .task-date-time .task-time {
            font-size: 10px;
            margin-top: -2px;
        }
        .task-content {
            flex: 1;
        }
        #calendar {
            position: absolute;
            top: 40px;
            left: 20px;
            right: 0;
            bottom: 0;
            overflow-y: auto;
        }
        .calendar-event {
            position: absolute;
            left: 60px;
            right: 0;
            padding: 5px;
            margin: 3.5px;
            background-color: #3a506b;
            color: #e0e0e0;
            border-radius: 3px;
            font-size: 12px;
            box-sizing: border-box;
        }
        .calendar-event.partial {
            background: linear-gradient(to bottom, #3a506b 0%, transparent 100%);
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .navigation button {
            background-color: #3a506b;
            color: #e0e0e0;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
        }
        .hour-marker {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px solid #444;
            pointer-events: none;
        }
        .hour-label {
            position: absolute;
            left: 0;
            width: 50px;
            text-align: right;
            padding-right: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        @keyframes slideUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }
        @keyframes slideInRight {
            0% { transform: translateX(100%); }
            100% { transform: translateX(0); }
        }
        @keyframes slideInLeft {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(0); }
        }
    </style>
</head>
<body>
    <div class="title">Scribblit</div>
    <div class="container">
        <div class="left-column">
            <div style="position: relative;">
                <textarea id="taskInput" spellcheck="false" placeholder="Scribble your tasks here..."></textarea>
                <div id="animationOverlay"></div>
            </div>
            <div class="task-section">
                <div class="section-title">Today</div>
                <div id="todayTaskList" class="task-list"></div>
            </div>
            <div class="task-section">
                <div class="section-title">Tomorrow</div>
                <div id="tomorrowTaskList" class="task-list"></div>
            </div>
            <div class="task-section">
                <div class="section-title">This Week</div>
                <div id="weekTaskList" class="task-list"></div>
            </div>
        </div>
        <div class="right-column">
            <div class="navigation">
                <button id="prevDay">&lt;</button>
                <span id="currentDate">Today</span>
                <button id="nextDay">&gt;</button>
            </div>
            <div id="calendar"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/2.3.1/luxon.min.js"></script>
    <script>
        // Global variable to store all tasks and events
        let taskEventDictionary = {};

        const DateTime = luxon.DateTime;
        let currentDate = DateTime.local();
        // rotate during testing
        // AIzaSyDgiM5ZhWqxsI_hoNAaJeSChCh5SkztGoc
        // AIzaSyDxLOhwro6jpIHUBssb_hcavahQwOGrjPQ
        const apiKey = 'AIzaSyDxLOhwro6jpIHUBssb_hcavahQwOGrjPQ';

        const taskInput = document.getElementById('taskInput');
        const originalHeight = '100px'; // Store the original height
        let isAnimating = false;
        let animationCooldown = false;

        const todayTaskList = document.getElementById('todayTaskList');
        const tomorrowTaskList = document.getElementById('tomorrowTaskList');
        const weekTaskList = document.getElementById('weekTaskList');
        const calendar = document.getElementById('calendar');
        const currentDateEl = document.getElementById('currentDate');
        const prevDayBtn = document.getElementById('prevDay');
        const nextDayBtn = document.getElementById('nextDay');

        taskInput.addEventListener('keydown', function(event) {
            // pressing enter and not shift+enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                processInput();
            }
        });

        prevDayBtn.addEventListener('click', () => changeDate(-1, 'left'));
        nextDayBtn.addEventListener('click', () => changeDate(1, 'right'));

        function changeDate(delta, direction) {
            const oldCalendar = calendar.cloneNode(true);
            oldCalendar.style.position = 'absolute';
            oldCalendar.style.top = '40px';
            oldCalendar.style.left = '20px';
            oldCalendar.style.right = '0';
            oldCalendar.style.bottom = '0';
            calendar.parentNode.appendChild(oldCalendar);

            currentDate = currentDate.plus({ days: delta });
            updateDateDisplay();

            oldCalendar.style.animation = 'slideUp 0.5s forwards';
            calendar.style.animation = direction === 'right' ? 'slideInRight 0.5s forwards' : 'slideInLeft 0.5s forwards';

            setTimeout(() => {
                oldCalendar.remove();
                renderCalendar();
            }, 500);
        }

        function adjustTextareaHeight() {
            if (!isAnimating && !animationCooldown) {
                taskInput.style.height = 'auto';
                taskInput.style.height = `${taskInput.scrollHeight}px`;
            }
        }

        taskInput.addEventListener('input', adjustTextareaHeight);

        function updateDateDisplay() {
            const today = DateTime.local();
            if (currentDate.hasSame(today, 'day')) {
                currentDateEl.textContent = 'Today';
            } else if (currentDate.hasSame(today.plus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Tomorrow';
            } else if (currentDate.hasSame(today.minus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Yesterday';
            } else {
                currentDateEl.textContent = currentDate.toFormat('M/d');
            }
        }

        async function processInput() {
            const input = taskInput.value;
            const animationOverlay = document.getElementById('animationOverlay');
            
            // Store current height
            const currentHeight = taskInput.style.height;
            
            // Set animating flag
            isAnimating = true;
            
            // Create animation
            const animatedText = document.createElement('div');
            animatedText.className = 'animated-text';
            animatedText.textContent = input;
            
            // Position the animated text precisely
            const inputRect = taskInput.getBoundingClientRect();
            const overlayRect = animationOverlay.getBoundingClientRect();
            
            animatedText.style.top = `${inputRect.top - overlayRect.top}px`;
            animatedText.style.left = `${inputRect.left - overlayRect.left}px`;
            animatedText.style.width = `${inputRect.width}px`;
            animatedText.style.height = `${inputRect.height}px`;
            
            animationOverlay.appendChild(animatedText);

            // Clear input but maintain height
            taskInput.value = '';
            taskInput.style.height = currentHeight;

            // Wait for text float animation to complete
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Clear animation overlay
            animationOverlay.innerHTML = '';

            // Animate text area back to original height
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            // Reset transition and set cooldown after animation
            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    // Adjust height after cooldown
                    adjustTextareaHeight();
                }, 500); // 500ms cooldown after animation
            }, 300);



            const prompt = `
            You are a task parsing AI. You will receive a list of tasks or events, potentially messy or informal. Your job is to format and structure this information.

            For each task or event:
            1. Apply proper formatting and capitalization.
            2. Infer the date. If no date is specified, assume it's for today (${currentDate.toFormat('yyyy-MM-dd')}). If "tomorrow" or a day of the week is mentioned, calculate the actual date.
            3. Determine the time, if applicable. If it's past noon and only a number is given (e.g., "at 3"), assume PM. Use reasoning to guess AM/PM when not explicitly stated.

            Respond with a JSON array. Each item may or may not have these properties:
            - kind: "task" or "event"
            - name: The formatted task name
            - date: If a date like "october 17th" is found put in YYYY-MM-DD format. If a day of the week is found like "this monday" return that day as a string like "monday". If a relative time like "tomorrow" or "today" is given, return "tomorrow" or "today". if a day phrase relative to the span of a week like "next monday" is given, return "monday+1". this extends to phrases like "2 mondays from now" or "next next monday" or others, which should return "monday+2"
            - startTime: In HH:mm format (24-hour) (only for events)
            - endTime: In HH:mm format (24-hour) (the end of an event or the due date of a task)
            If a field cannot be inferred, instead of giving a null value just omit it completely. For example: if not time is given, don't provide the startTime or endTime fields.
            
            The input you are given is written very quickly and hastily, so you should expand parts where they meant a word but just typed a few characters. Like "HW" should be expanded to "Homework". This doesn't mean you should expand acronyms. Also remove words from the name that provide no value, like "due". So "slideshow due for Bio" should be "Slideshow for Bio". Omit trailing commas in the JSON.

            Input:
            ${input}

            Give me a JSON response and nothing else. Don't put it in a code block.`;

            try {
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=' + apiKey, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const data = await response.json();
                const rawText = data.candidates[0].content.parts[0].text;
                console.log('Raw text:', rawText);
                
                // Remove Markdown formatting and parse JSON
                let jsonText;
                if (!rawText.includes('```json')) {
                    jsonText = rawText.replace(/```json\n|\n```/g, '').trim();
                }
                const parsedTasks = JSON5.parse(jsonText);
                updateTaskEventDictionary(parsedTasks);
                saveToLocalStorage();
                renderAllData();
                
                renderTasks(parsedTasks);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function updateTaskEventDictionary(newItems) {
            newItems.forEach(item => {
                const key = `${item.kind}_${item.name}_${item.date}`;
                taskEventDictionary[key] = item;
            });
        }

        function renderAllData() {
            todayTaskList.innerHTML = '';
            tomorrowTaskList.innerHTML = '';
            weekTaskList.innerHTML = '';
            renderCalendar();

            const today = DateTime.local();
            const tomorrow = today.plus({ days: 1 });
            const weekEnd = today.plus({ days: 7 });

            Object.values(taskEventDictionary).forEach(item => {
                let itemDate = parseTaskDate(item.date);

                if (item.kind === "event") {
                    renderCalendarEvent(item, itemDate);
                } else if (item.kind === "task") {
                    renderTaskItem(item, itemDate, today, tomorrow, weekEnd);
                }
            });
        }

        function renderCalendarEvent(item, itemDate) {
            if (itemDate.hasSame(currentDate, 'day')) {
                const eventEl = document.createElement('div');
                eventEl.className = 'calendar-event';
                eventEl.textContent = item.name;
                
                const startMinutes = timeToMinutes(item.startTime);
                eventEl.style.top = `${startMinutes / 1440 * 100}%`;
                
                if (item.endTime) {
                    const endMinutes = timeToMinutes(item.endTime);
                    const duration = endMinutes - startMinutes;
                    eventEl.style.height = `calc(${duration / 1440 * 100}% - 7px)`;
                } else {
                    eventEl.classList.add('partial');
                    eventEl.style.height = '60px'; // 1 hour
                }

                calendar.appendChild(eventEl);
            }
        }

        function renderTaskItem(item, itemDate, today, tomorrow, weekEnd) {
            const listItem = document.createElement('div');
            const taskContent = document.createElement('span');
            taskContent.className = 'task-content';
            taskContent.textContent = item.name;

            if (itemDate.hasSame(today, 'day')) {
                appendTaskToList(listItem, taskContent, item, todayTaskList);
            } else if (itemDate.hasSame(tomorrow, 'day')) {
                appendTaskToList(listItem, taskContent, item, tomorrowTaskList, itemDate, today, tomorrow);
            } else if (itemDate > tomorrow && itemDate <= weekEnd) {
                appendTaskToWeekList(listItem, taskContent, item, itemDate, weekTaskList);
            }
        }

        function appendTaskToList(listItem, taskContent, item, targetList, itemDate, today, tomorrow) {
            const timeSpan = document.createElement('span');
            if (item.endTime) {
                timeSpan.className = 'task-time';
                timeSpan.textContent = item.endTime;
            }

            // only add the asterisk when in the today or tomorrow section and there's no time
            if (item.kind === 'task' && !item.startTime && !item.endTime && (itemDate.hasSame(today, 'day') || itemDate.hasSame(tomorrow, 'day'))) {
                timeSpan.className = 'task-asterisk';
                timeSpan.textContent = '*';
            }

            listItem.appendChild(timeSpan);
            listItem.appendChild(taskContent);
            targetList.appendChild(listItem);
        }

        function appendTaskToWeekList(listItem, taskContent, item, itemDate, targetList) {
            const dateTimeSpan = document.createElement('span');
            dateTimeSpan.className = 'task-date-time';
            const dateSpan = document.createElement('span');
            dateSpan.className = 'task-date';
            dateSpan.textContent = itemDate.toFormat('MM/dd');
            dateTimeSpan.appendChild(dateSpan);
            
            if (item.endTime) {
                const timeSpan = document.createElement('span');
                timeSpan.className = 'task-time';
                timeSpan.textContent = item.endTime;
                dateTimeSpan.appendChild(timeSpan);
            } else {
                const asteriskSpan = document.createElement('span');
                asteriskSpan.className = 'task-asterisk';
                asteriskSpan.textContent = '*';
                dateTimeSpan.appendChild(asteriskSpan);
            }
            
            listItem.appendChild(dateTimeSpan);
            listItem.appendChild(taskContent);
            targetList.appendChild(listItem);
        }

        function renderCalendar() {
            calendar.innerHTML = '';
            renderCalendarTimeMarkers();
            
            Object.values(taskEventDictionary).forEach(item => {
                if (item.kind === "event") {
                    const itemDate = parseTaskDate(item.date);
                    renderCalendarEvent(item, itemDate);
                }
            });
        }

        function renderTasks(tasks) {
            todayTaskList.innerHTML = '';
            tomorrowTaskList.innerHTML = '';
            weekTaskList.innerHTML = '';
            calendar.innerHTML = '';

            renderCalendarTimeMarkers();

            const today = DateTime.local();
            const tomorrow = today.plus({ days: 1 });
            const weekEnd = today.plus({ days: 7 });

            tasks.forEach(item => {
                let itemDate = parseTaskDate(item.date);

                if (item.kind === "event") {
                    // This is an event, so we only add it to the calendar
                    if (itemDate.hasSame(currentDate, 'day')) {
                        const eventEl = document.createElement('div');
                        eventEl.className = 'calendar-event';
                        eventEl.textContent = item.name;
                        
                        const startMinutes = timeToMinutes(item.startTime);
                        eventEl.style.top = `${startMinutes / 1440 * 100}%`;
                        
                        if (item.endTime) {
                            const endMinutes = timeToMinutes(item.endTime);
                            const duration = endMinutes - startMinutes;
                            eventEl.style.height = `calc(${duration / 1440 * 100}% - 7px)`;
                        } else {
                            eventEl.classList.add('partial');
                            eventEl.style.height = '60px'; // 1 hour
                        }

                        calendar.appendChild(eventEl);
                    }
                } else if (item.kind === "task") {
                    const listItem = document.createElement('div');
                    const taskContent = document.createElement('span');
                    taskContent.className = 'task-content';
                    taskContent.textContent = item.name;

                    if (itemDate.hasSame(today, 'day')) {
                        const timeSpan = document.createElement('span');
                        if (item.endTime) {
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = item.endTime;
                        } else {
                            timeSpan.className = 'task-asterisk';
                            timeSpan.textContent = '*';
                        }
                        listItem.appendChild(timeSpan);
                        listItem.appendChild(taskContent);
                        todayTaskList.appendChild(listItem);
                    } else if (itemDate.hasSame(tomorrow, 'day')) {
                        const timeSpan = document.createElement('span');
                        if (item.endTime) {
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = item.endTime;
                        } else {
                            timeSpan.className = 'task-asterisk';
                            timeSpan.textContent = '*';
                        }
                        listItem.appendChild(timeSpan);
                        listItem.appendChild(taskContent);
                        tomorrowTaskList.appendChild(listItem);
                    } else if (itemDate > tomorrow && itemDate <= weekEnd) {
                        const dateTimeSpan = document.createElement('span');
                        dateTimeSpan.className = 'task-date-time';
                        const dateSpan = document.createElement('span');
                        dateSpan.className = 'task-date';
                        dateSpan.textContent = itemDate.toFormat('MM/dd');
                        dateTimeSpan.appendChild(dateSpan);
                        
                        if (item.endTime) {
                            const timeSpan = document.createElement('span');
                            timeSpan.className = 'task-time';
                            timeSpan.textContent = item.endTime;
                            dateTimeSpan.appendChild(timeSpan);
                        }
                        
                        listItem.appendChild(dateTimeSpan);
                        listItem.appendChild(taskContent);
                        weekTaskList.appendChild(listItem);
                    }
                }
            });
        }

        function parseTaskDate(dateString) {
            const today = DateTime.local();

            if (dateString) {
                if (dateString === 'today') {
                    return today;
                } else if (dateString === 'tomorrow') {
                    return today.plus({ days: 1 });
                } else if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    return DateTime.fromISO(dateString);
                } else if (dateString.match(/^[a-z]+(\+\d+)?$/)) {
                    const [day, offset] = dateString.split('+');
                    let targetDate = today.set({ weekday: getDayNumber(day) });
                    
                    if (offset) {
                        targetDate = targetDate.plus({ weeks: parseInt(offset) });
                    }
                    
                    if (targetDate < today) {
                        targetDate = targetDate.plus({ weeks: 1 });
                    }
                    
                    return targetDate;
                }
            }

            // If we can't parse the date, return today as a fallback
            console.error(`Unable to parse date: ${dateString}`);
            return today;
        }

        function getDayNumber(day) {
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
            return days.indexOf(day.toLowerCase()) + 1;
        }

        function timeToMinutes(time) {
            const [hours, minutes] = time.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function renderCalendarTimeMarkers() {
            for (let i = 0; i < 24; i++) {
                const hourMarker = document.createElement('div');
                hourMarker.className = 'hour-marker';
                hourMarker.style.top = `${i / 24 * 100}%`;

                const hourLabel = document.createElement('div');
                hourLabel.className = 'hour-label';
                hourLabel.textContent = `${i.toString().padStart(2, '0')}:00`;
                hourLabel.style.top = `${i / 24 * 100}%`;

                calendar.appendChild(hourMarker);
                calendar.appendChild(hourLabel);
            }
        }

        function renderCalendar() {
            calendar.innerHTML = '';
            renderCalendarTimeMarkers();
        }

        function loadFromLocalStorage() {
            const storedData = localStorage.getItem('taskEventDictionary');
            if (storedData) {
                taskEventDictionary = JSON.parse(storedData);
            }
        }

        function saveToLocalStorage() {
            localStorage.setItem('taskEventDictionary', JSON.stringify(taskEventDictionary));
        }

        loadFromLocalStorage();
        updateDateDisplay();
        renderAllData();
        adjustTextareaHeight();
    </script>
</body>
</html>