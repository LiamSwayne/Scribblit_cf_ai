<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scribblit</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" 
    rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            flex-grow: 1;
        }
        .left-column {
            flex: 1;
            padding-right: 20px;
            display: flex;
            flex-direction: column;
        }
        .right-column {
            flex: 1;
            border-left: 1px solid #444;
            padding-left: 20px;
            position: relative;
            overflow: hidden;
        }
        #taskInput {
            width: 100%;
            min-height: 100px;
            margin-bottom: 20px;
            background-color: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 10px;
            resize: none;
            position: relative;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-y: hidden;
            box-sizing: border-box;
            transition: min-height 0.3s ease, height 0.3s ease;
        }
        #taskInput:focus {
            outline: none;
            border-color: #444;
        }
        #animationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
        }
        .animated-text {
            position: absolute;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #e0e0e0;
            padding: 10px;
            background-color: #2d2d2d;
            opacity: 0;
            animation: floatAway 1s forwards;
            box-sizing: border-box;
            border: 1px solid transparent;
        }
        @keyframes floatAway {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }
        .task-section {
            margin-bottom: 20px;
        }
        .task-list {
            list-style-type: none;
            padding: 0;
        }
        .task-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        .task-asterisk {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            color: #888;
            margin-right: 10px;
            min-width: 60px;
            text-align: right;
            margin-top: -2px; /* Align with the first line of text */
        }
        .task-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            color: #888;
            margin-right: 10px;
            min-width: 60px;
            text-align: right;
        }
        .task-asterisk {
            min-width: 20px;
        }
        .task-content {
            flex: 1;
        }
        #calendar {
            position: absolute;
            top: 40px;
            left: 20px;
            right: 0;
            bottom: 0;
            overflow-y: auto;
        }
        .calendar-event {
            position: absolute;
            left: 60px;
            right: 0;
            padding: 5px;
            margin: 3.5px;
            background-color: #3a506b;
            color: #e0e0e0;
            border-radius: 3px;
            font-size: 12px;
            box-sizing: border-box;
        }
        .calendar-event.partial {
            background: linear-gradient(to bottom, #3a506b 0%, transparent 100%);
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .navigation button {
            background-color: #3a506b;
            color: #e0e0e0;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
        }
        .hour-marker {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px solid #444;
            pointer-events: none;
        }
        .hour-label {
            position: absolute;
            left: 0;
            width: 50px;
            text-align: right;
            padding-right: 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        @keyframes slideUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100%); opacity: 0; }
        }
        @keyframes slideInRight {
            0% { transform: translateX(100%); }
            100% { transform: translateX(0); }
        }
        @keyframes slideInLeft {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(0); }
        }
    </style>
</head>
<body>
    <h1>Scribblit</h1>
    <div class="container">
        <div class="left-column">
            <div style="position: relative;">
                <textarea id="taskInput" placeholder="Scribble your tasks here..."></textarea>
                <div id="animationOverlay"></div>
            </div>
            <div class="task-section">
                <h2>Today</h2>
                <ul id="todayTaskList" class="task-list"></ul>
            </div>
            <div class="task-section">
                <h2>Tomorrow</h2>
                <ul id="tomorrowTaskList" class="task-list"></ul>
            </div>
            <div class="task-section">
                <h2>This Week</h2>
                <ul id="weekTaskList" class="task-list"></ul>
            </div>
        </div>
        <div class="right-column">
            <div class="navigation">
                <button id="prevDay">&lt;</button>
                <span id="currentDate">Today</span>
                <button id="nextDay">&gt;</button>
            </div>
            <div id="calendar"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/2.3.1/luxon.min.js"></script>
    <script>
        const DateTime = luxon.DateTime;
        let currentDate = DateTime.local();
        const apiKey = 'AIzaSyDgiM5ZhWqxsI_hoNAaJeSChCh5SkztGoc';

        const taskInput = document.getElementById('taskInput');
        const originalHeight = '100px'; // Store the original height
        let isAnimating = false;
        let animationCooldown = false;

        const todayTaskList = document.getElementById('todayTaskList');
        const tomorrowTaskList = document.getElementById('tomorrowTaskList');
        const weekTaskList = document.getElementById('weekTaskList');
        const calendar = document.getElementById('calendar');
        const currentDateEl = document.getElementById('currentDate');
        const prevDayBtn = document.getElementById('prevDay');
        const nextDayBtn = document.getElementById('nextDay');

        taskInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && event.ctrlKey) {
                event.preventDefault();
                processInput();
            }
        });

        prevDayBtn.addEventListener('click', () => changeDate(-1, 'left'));
        nextDayBtn.addEventListener('click', () => changeDate(1, 'right'));

        function changeDate(delta, direction) {
            const oldCalendar = calendar.cloneNode(true);
            oldCalendar.style.position = 'absolute';
            oldCalendar.style.top = '40px';
            oldCalendar.style.left = '20px';
            oldCalendar.style.right = '0';
            oldCalendar.style.bottom = '0';
            calendar.parentNode.appendChild(oldCalendar);

            currentDate = currentDate.plus({ days: delta });
            updateDateDisplay();

            oldCalendar.style.animation = 'slideUp 0.5s forwards';
            calendar.style.animation = direction === 'right' ? 'slideInRight 0.5s forwards' : 'slideInLeft 0.5s forwards';

            setTimeout(() => {
                oldCalendar.remove();
                renderCalendar();
            }, 500);
        }

        function adjustTextareaHeight() {
            if (!isAnimating && !animationCooldown) {
                taskInput.style.height = 'auto';
                taskInput.style.height = `${taskInput.scrollHeight}px`;
            }
        }

        taskInput.addEventListener('input', adjustTextareaHeight);

        // Initial adjustment
        adjustTextareaHeight();

        function updateDateDisplay() {
            const today = DateTime.local();
            if (currentDate.hasSame(today, 'day')) {
                currentDateEl.textContent = 'Today';
            } else if (currentDate.hasSame(today.plus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Tomorrow';
            } else if (currentDate.hasSame(today.minus({ days: 1 }), 'day')) {
                currentDateEl.textContent = 'Yesterday';
            } else {
                currentDateEl.textContent = currentDate.toFormat('M/d');
            }
        }

        async function processInput() {
            const input = taskInput.value;
            const animationOverlay = document.getElementById('animationOverlay');
            
            // Store current height
            const currentHeight = taskInput.style.height;
            
            // Set animating flag
            isAnimating = true;
            
            // Create animation
            const animatedText = document.createElement('div');
            animatedText.className = 'animated-text';
            animatedText.textContent = input;
            
            // Position the animated text precisely
            const inputRect = taskInput.getBoundingClientRect();
            const overlayRect = animationOverlay.getBoundingClientRect();
            
            animatedText.style.top = `${inputRect.top - overlayRect.top}px`;
            animatedText.style.left = `${inputRect.left - overlayRect.left}px`;
            animatedText.style.width = `${inputRect.width}px`;
            animatedText.style.height = `${inputRect.height}px`;
            
            animationOverlay.appendChild(animatedText);

            // Clear input but maintain height
            taskInput.value = '';
            taskInput.style.height = currentHeight;

            // Wait for text float animation to complete
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Clear animation overlay
            animationOverlay.innerHTML = '';

            // Animate text area back to original height
            taskInput.style.transition = 'height 0.3s ease';
            taskInput.style.height = originalHeight;

            // Reset transition and set cooldown after animation
            setTimeout(() => {
                taskInput.style.transition = '';
                isAnimating = false;
                animationCooldown = true;
                setTimeout(() => {
                    animationCooldown = false;
                    // Adjust height after cooldown
                    adjustTextareaHeight();
                }, 500); // 500ms cooldown after animation
            }, 300);



            const prompt = `
            You are a task parsing AI. You will receive a list of tasks or events, potentially messy or informal. Your job is to format and structure this information.

            For each task or event:
            1. Apply proper formatting and capitalization.
            2. Infer the date. If no date is specified, assume it's for today (${currentDate.toFormat('yyyy-MM-dd')}). If "tomorrow" or a day of the week is mentioned, calculate the actual date.
            3. Determine the time, if applicable. If it's past noon and only a number is given (e.g., "at 3"), assume PM. Use reasoning to guess AM/PM when not explicitly stated.

            Respond with a JSON array. Each item may or may not have these properties:
            - name: The formatted task name
            - date: If a date like "october 17th" is found put in YYYY-MM-DD format. If a day of the week is found like "this monday" return that day as a string like "monday". If a relative time like "tomorrow" or "today" is given, return "tomorrow" or "today". if a day phrase relative to the span of a week like "next monday" is given, return "monday+1". this extends to phrases like "2 mondays from now" or "next next monday" or others, which should return "monday+2"
            - startTime: In HH:mm format (24-hour)
            - endTime: In HH:mm format (24-hour)
            If a field cannot be inferred, instead of giving a null value just omit it completely. For example: if not time is given, don't provide the startTime or endTime fields.
            
            The tasks you are given are written very quickly and hastily, so you should expand parts where they meant a word but just typed a few characters. Like "HW" should be expanded to "Homework". This doesn't mean you should expand acronyms. Also remove words from the name that provide no value, like "due". So "slideshow due for Bio" should be "Slideshow for Bio".

            Input:
            ${input}

            Give me a JSON response and nothing else. Don't put it in a code block.`;

            try {
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=' + apiKey, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const data = await response.json();
                const rawText = data.candidates[0].content.parts[0].text;
                console.log('Raw text:', rawText);
                
                // Remove Markdown formatting and parse JSON
                const jsonText = rawText.replace(/```json\n|\n```/g, '').trim();
                const parsedTasks = JSON.parse(jsonText);
                
                renderTasks(parsedTasks);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function renderTasks(tasks) {
            todayTaskList.innerHTML = '';
            tomorrowTaskList.innerHTML = '';
            weekTaskList.innerHTML = '';
            calendar.innerHTML = '';

            renderCalendarTimeMarkers();

            const today = DateTime.local();
            const tomorrow = today.plus({ days: 1 });
            const weekEnd = today.plus({ days: 7 });

            tasks.forEach(task => {
                const listItem = document.createElement('li');
                const taskContent = document.createElement('span');
                taskContent.className = 'task-content';
                taskContent.textContent = task.name;

                let taskDate = parseTaskDate(task.date);

                if (taskDate.hasSame(today, 'day')) {
                    const asterisk = document.createElement('span');
                    asterisk.className = 'task-asterisk';
                    asterisk.textContent = '*';
                    listItem.appendChild(asterisk);
                    listItem.appendChild(taskContent);
                    todayTaskList.appendChild(listItem);
                } else if (taskDate.hasSame(tomorrow, 'day')) {
                    const asterisk = document.createElement('span');
                    asterisk.className = 'task-asterisk';
                    asterisk.textContent = '*';
                    listItem.appendChild(asterisk);
                    listItem.appendChild(taskContent);
                    tomorrowTaskList.appendChild(listItem);
                } else if (taskDate > tomorrow && taskDate <= weekEnd) {
                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'task-date';
                    dateSpan.textContent = taskDate.toFormat('MM-dd');
                    listItem.appendChild(dateSpan);
                    listItem.appendChild(taskContent);
                    weekTaskList.appendChild(listItem);
                }

                if (task.startTime && taskDate.hasSame(currentDate, 'day')) {
                    const eventEl = document.createElement('div');
                    eventEl.className = 'calendar-event';
                    eventEl.textContent = `${task.startTime} - ${task.name}`;
                    
                    const startMinutes = timeToMinutes(task.startTime);
                    eventEl.style.top = `${startMinutes / 1440 * 100}%`;
                    
                    if (task.endTime) {
                        const endMinutes = timeToMinutes(task.endTime);
                        const duration = endMinutes - startMinutes;
                        eventEl.style.height = `calc(${duration / 1440 * 100}% - 7px)`;
                    } else {
                        eventEl.classList.add('partial');
                        eventEl.style.height = '60px'; // 1 hour
                    }

                    calendar.appendChild(eventEl);
                }
            });
        }

        function parseTaskDate(dateString) {
            const today = DateTime.local();

            if (dateString === 'today') {
                return today;
            } else if (dateString === 'tomorrow') {
                return today.plus({ days: 1 });
            } else if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return DateTime.fromISO(dateString);
            } else if (dateString.match(/^[a-z]+(\+\d+)?$/)) {
                const [day, offset] = dateString.split('+');
                let targetDate = today.set({ weekday: getDayNumber(day) });
                
                if (offset) {
                    targetDate = targetDate.plus({ weeks: parseInt(offset) });
                }
                
                if (targetDate < today) {
                    targetDate = targetDate.plus({ weeks: 1 });
                }
                
                return targetDate;
            }

            // If we can't parse the date, return today as a fallback
            console.error(`Unable to parse date: ${dateString}`);
            return today;
        }

        function getDayNumber(day) {
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
            return days.indexOf(day.toLowerCase()) + 1;
        }

        function timeToMinutes(time) {
            const [hours, minutes] = time.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function renderCalendarTimeMarkers() {
            for (let i = 0; i < 24; i++) {
                const hourMarker = document.createElement('div');
                hourMarker.className = 'hour-marker';
                hourMarker.style.top = `${i / 24 * 100}%`;

                const hourLabel = document.createElement('div');
                hourLabel.className = 'hour-label';
                hourLabel.textContent = `${i.toString().padStart(2, '0')}:00`;
                hourLabel.style.top = `${i / 24 * 100}%`;

                calendar.appendChild(hourMarker);
                calendar.appendChild(hourLabel);
            }
        }

        function renderCalendar() {
            calendar.innerHTML = '';
            renderCalendarTimeMarkers();
        }

        updateDateDisplay();
        renderCalendar();
    </script>
</body>
</html>